---
title: "64비트 멀티코어 OS 원리와 구조"
date: 2025-11-04 00:00:00 +0900
categories: [Books]
tags: [OS]
permalink: /posts/64-OS-project/
---
## 64비트 멀티코어 OS 원리와 구조
책을 읽어보며 새로 알게된 사실이나 잘못 알고 있었던 점들을 정리해보고자 하는 글입니다. 저는 Ubuntu 리눅스 환경에서 진행하였습니다.

## 2장 (개발환경 구축)
GCC(GNU Compiler Collection)를 설치해야 합니다. 리눅스 환경은 gcc를 쉽게 설치할 수 있으나 

```
sudo apt install gcc-multilib
```
위 패키지를 설치하여 gcc가 32비트를 지원하도록 할 수 있습니다. NASM(The Network Assembler), QEMU 역시 그냥 설치해주면 됩니다.

## 3장 (64비트 프로세스)
인텔 64비트 호환 프로세서(이하 **x86-64 프로세서**)에는 크게 다섯 가지 운영 모드가 있습니다.

- 리얼 모드: 프로세서의 초기 상태로서 `16비트 모드`로 동작하며 8086 프로세서와 호환되는 모드입니다. 최대 **1MB(2^20)** 주소 공간을 지원합니다.
- 보호 모드: `32비트 모드`로 동작하며, 세그먼트, 페이징 보호, 멀티태스킹 등의 기능을 제공합니다. **4GB(2^32)** 주소 공간을 지원합니다.
- IA-32e 모드: 32비트 호환 모드와 64비트 모드의 두 가지 서브모드로 구성됩니다. **16EB(2^64)** 주소 공간을 지원합니다.
- 시스템 관리 모드: 전원 관리나 하드웨어 제어 같은 특수 기능을 제공합니다.
- 가상 8086 모드: 보호 모드 내부에서 가상의 환경을 설정하여 리얼 모드처럼 동작하는 모드입니다.

위 모드 중 64비트 OS가 반드시 지원해야 하는 모드는 리얼 모드, 보호 모드, IA-32e 모드 중 64비트 서브 모드 총 세 가지가 있습니다. 

### 리얼 모드
프로세서가 어떤 상태나 모드에 있든, 전원이 켜지거나 리셋되면 프로세서는 리얼 모드로 진입합니다. 리얼 모드는 과거 16비트 프로세서와 동일하게 동작하며, BIOS의 여러 기능을 사용할 수 있습니다. 리얼 모드에서 하는 작업은 **OS 이미지를 디스크에서 메모리로 복사하여 보호 모드로 변경** 하는 것 밖에 없으나 대부분 작업을 어셈블리어로 처리합니다. 

### 보호 모드
보호 모드는 32비트 윈도우나 리눅스 OS가 동작하는 기본 모드로, IA-32e 모드로 전환하려면 반드시 거쳐야 하는 모드입니다. 최대 4G(2^32) 주소 공간을 제공하며 멀티태스킹, 세그먼테이션, 페이징 등의 기능을 하드웨어적으로 지원합니다. 여러 기능을 지원하는만큼 레지스터와 자료구조 역시 다양합니다.

### IA-32e 모드
서브 모드로 32비트 호환 모드와 64비트 모드가 있습니다. 프로세서가 32비트 호환 모드일 때는 보호 모드에 있는 것처럼 동작하기에 32비트 코드를 그대로 실행할 수 있습니다.  <br>

![전환](/assets/img/posts/books/64bit/ch3_1.png) <br>

위 그림은 각 운영 모드의 관계와 전환 조건을 나타내고 있습니다. 화살표가 연결되지 않은 모드끼리의 전환은 리셋이나 예외를 초래할 수 있습니다. 

아래 그림은 보호 모드와 IA-32e 모드에서의 레지스터를 나타내고 있습니다. <br>

![보호모드_레지스터](/assets/img/posts/books/64bit/ch3_2.png) <br>
![IA3e레지스터](/assets/img/posts/books/64bit/ch3_3.png) <br>

x86-64 프로세서에는 많은 레지스터가 있지만, OS 개발에 있어 큰 비중을 차지하는 레지스터는 **범용 레지스터, 세그먼트 레지스터, 컨트롤 레지스터** 세 가지입니다. 

### 범용 레지스터

범용 레지스터(General Purpose Register)는 계산, 메모리 어드레스 지정, 임시 저장 공간 등의 목적으로 사용합니다. 16비트와 32비트 모드를 지원하는 x86 계열(인텔 32비트 호환 프로세서)은 8개, 64비트 모드를 지원하는 x86-64 계열은 16개가 있습니다. x86-64 프로세서에는 x86 프로세서의 범용 레지스터 외에도 `R8 ~ R15`로 이름 붙여진 8개의 레지스터가 더 있는데, 차이점이 있다면 **특수한 용도가 정의되지 않았다** 는 것입니다. 다른 범용 레지스터들은 용도가 고정되지 않아 다양하게 사용될 수 있지만, 특정 명령어는 특정 레지스터와 같이 사용해야 합니다. 

|범용 레지스터 이름|용도|
|--------------|---|
|AX|산술 연산을 수행할 때 누산자로 사용|
|BX|데이터의 어드레스를 지정할 때 데이터 포인터로 사용|
|CX|루프 또는 문자열의 카운터|
|DX|I/O 어드레스를 지정할 때 사용되며, 산술 연산 수행할 때 보조 레지스터로 사용|
|SI|문자열에 관련된 작업을 할 때 원본 문자열의 인덱스로 활용|
|DI|문자열에 관련된 작업을 할 때 목적지 문자열의 인덱스로 활용|
|SP|스택의 포인터로 사용|
|BP|스택의 데이터에 접근할 때 데이터의 포인터로 사용|
|R8~R15| 다양한 용도로 사용|

그러나 레지스터들이 프로세서의 운영 모드마다 개별적으로 존재하는 것은 아닙니다. x86-64 프로세서는 64비트 크기의 범용 레지스터만 있으며 보호 모드나 리얼 모드일 때 **레지스터의 일부 영역만을** 사용하도록 처리하고 있습니다. 64비트 범용 레지스터는 `하위 32비트`, `16비트`, `8비트`의 크기로 구분하여 접근할 수 있고 레지스터에 **접두사(prefix)** 나 **접미사(postfix)** 를 붙여 접근하는 크기를 표시합니다. 대체로 64비트 크기 레지스터에는 RAX, RBP처럼 R 접두사가 붙고, 32비트 크기는 EAX,EBP처럼 E나 D 접두사, 16비트 크기는 안 붙거나 W 접미사가 붙습니다. 16비트 이하 크기는 상위 8비트와 하위 8비트로 구분하여 상위 8비트는 AH, BH처럼 끝자리에 H를 붙여 부르고, 하위 8비트는 AL, BL처럼 끝자리에 L을 붙입니다. 다음 그림에서 운영 모드별 접근 가능한 레지스터를 확인할 수 있습니다. <br>

![ch3_4](/assets/img/posts/books/64bit/ch3_4.png) <br>

위 그림과 달리 **오퍼랜드 크기 접두사(0x66)** 와 **어드레스 크기 접두사(0x67)** 을 사용하면 리얼 모드에서도 32비트 레지스터에 접근할 수 있습니다(모드 전환하는 상황에서 주로 사용). 보호 모드에서 16비트 레지스터에 접근할 때도 마찬가지입니다. IA-32e 모드의 경우 기존의 두 가지 접두사와 새로 추가된 **REX** 접두사를 사용하여 다양한 크기의 레지스터를 사용할 수 있습니다. 여기서 접두사라 함은 기계어 instruction 앞에 66이나 67, 혹은 66 67을 붙이는 것을 의미합니다. 운영 모드에 따라 접두사를 결합하는 방법에 일정한 규칙이 있으며, 다음 표에서는 운영 모드와 접두사에 따라 오퍼랜드와 어드레스의 크기가 어떻게 변화하는지 나타내고 있습니다. <br>

![ch3_5](/assets/img/posts/books/64bit/ch3_5.png) <br>

위의 표에서 눈여겨 봐야 할 점은 **IA-32e모드의 기본 오퍼랜드 크기가 32비트로 표시** 되었다는 것입니다. 기본 어드레스 크기는 64비트로 설계되었으나 기본 오퍼랜드 크기는 32비트로 설계되어 64비트 어드레스를 표현할 수 없고, **RIP 상대 어드레스** 라는 새로운 어드레스 계산 방식이 도입되었습니다. 

RIP 레지스터는 현재 실행 중인 명령의 주소를 나타내는 레지스터이고, 크기는 64비트입니다. RIP 레지스터의 값과 `32비트 오퍼랜드`를 통해 **64비트 주소 공간** 을 나타낼 수 있으며, 이게 RIP 상대 어드레스 지정방법입니다. 그러나 기본 오퍼랜드의 크기가 32비트라 위아래로 2G 범위까지만 표현이 가능하고, 이 범위를 벗어나려면 64비트 오퍼랜드와 관련있는 **REX** 접두사를 사용합니다. 이 접두사를 사용하면 오퍼랜드 크기가 64비트가 되어 64비트 어드레스를 모두 표현할 수 있게 됩니다. 

### 세그먼트 레지스터
세그먼트 레지스터(Segment Register)는 16비트 레지스터로 어드레스 영역을 다양한 크기로 구분하는 역할을 합니다. 리얼 모드에서는 단순히 고정된 크기의 어드레스 영역을 지정하는 역할만 하지만, 보호 모드와 IA-32e 모드에서는 **접근 권한**, **세그먼트의 시작 어드레스와 크기** 등을 지정하는 데에도 사용됩니다. 세그먼트 레지스터는 **CS, DS, SS, ES, FS, GS** 총 6개로 구성되며, 각 레지스터의 역할은 다음과 같습니다. <br>

![ch3_6](/assets/img/posts/books/64bit/ch3_6.png) <br>

세그먼트 레지스터의 역할은 **주소 공간을 목적에 따라 구분하는 것** 이며, 이는 세그먼테이션이나 페이징 같은 메모리 관리 기법으로 이어집니다. 

### 컨트롤 레지스터
컨트롤 레지스터(Control Register)는 운영 모드를 변경하고, 현재 운영 중인 모드의 특정 기능을 제어하는 레지스터입니다. x86 프로세서에는 CR0, CR1, CR2, CR3, CR4 총 5개의 컨트롤 레지스터가 있고, x86-64 프로세서에는 CR8이 추가되어 총 6개가 있습니다. 각 레지스터의 역할은 다음 표와 같습니다. <br>

![ch3_7](/assets/img/posts/books/64bit/ch3_7.png) <br>

컨트롤 레지스터는 리얼 모드와 보호 모드일 때는 32비트 크기이고, IA-32e 모드에서는 64비트 크기이나 제약사항이 있습니다. CR0, CR4, CR8 레지스터는 64비트 중 상위 32비트를 0으로 설정해야 하며, CR3 레지스터는 비트 40부터 비트 51까지 모두 0으로 설정해야 합니다. 대략적인 구조는 다음 그림과 같습니다. <br>

![ch3_8](/assets/img/posts/books/64bit/ch3_8.png) <br>

### 운영 모드와 메모리 관리 기법
x86-64 프로세서에서 지원하는 메모리 관리 기법은 크게 두 가지: 세그멘테이션, 페이징이 있습니다. 세그멘테이션은 전체 영역을 원하는 크기로 나누어 관리하는 방식이고, 페이징은 일정한 단위로 잘라진 조각을 모아 원하는 크기로 관리하는 방식이라고 볼 수 있습니다. 메모리 관리 기법을 사용하려면 관련 레지스터에 특정한 자료구조를 설정해야 합니다. 

세그먼테이션은 세그먼트 레지스터에 세그먼트의 시작 주소 혹은 **디스크립터(Descriptor)** 라고 불리는 자료구조의 위치를 설정해야 합니다. 

페이징은 **CR3 레지스터에 페이지 디렉터리** 라고 불리는 자료구조의 물리 주소를 설정해야 사용할 수 있습니다. 운영 모드에 따라 지원하는 기능이 다르고, 같은 메모리 관리 기법을 사용해도 모드에 따라 필드의 의미가 달라지는 경우도 있으나, 큰 줄기는 변하지 않습니다. 

#### 리얼 모드에서의 메모리 관리 방식
리얼 모드는 **최대 1MB** 까지 주소 공간을 사용하고 **세그먼테이션만** 지원합니다. 리얼 모드에서 세그먼트 크기는 `64K` 고정이고, 세그먼트의 시작 어드레스는 **세그먼트 레지스터에 직접 설정** 합니다. 세그먼테이션에서 세그먼트의 시작 어드레스는 코드나 메모리에 접근할 때 **기준 어드레스(Base Address)** 로 사용이 되는데, 그 관계는 아래 그림에서 나타내고 있습니다. <br>

![ch3_9](/assets/img/posts/books/64bit/ch3_9.png) <br>

리얼 모드는 페이징을 사용하지 않으므로 물리 주소로 변환하는 방식이 비교적 간단합니다. 세그먼테이션을 거쳐 나온 주소가 바로 물리 주소가 됩니다. 리얼 모드의 세그먼테이션은 세그먼트 레지스터의 값에 범용 레지스터 값을 더하는 방식으로 동작합니다. 이때 최대 `16MB` 영역까지 접근하기 위해 16비트 크기 두 값을 그대로 더하는 것이 아니라, **세그먼트 레지스터에 16을 곱한 값** 을 기준 주소로 사용합니다. 즉 16비트의 최댓값인 65535(2^16-1)에 16을 곱한 **1048560(2^20-16)** 값을 사용하여 1MB까지 접근할 수 있게 되는 것입니다. 

세그먼트의 크기가 `64KB`인 이유는 범용 레지스터의 크기 때문입니다. 접두사를 특별하게 쓰지 않는 이상 범용 레지스터의 크기는 16비트이기 때문에 접근할 수 있는 범위 역시 0~65535(0xffff)가 됩니다. 보호 모드도 계산 방식이 비슷하지만, **페이징** 이 추가되어서 계산 결과가 물리 주소가 아닌 **선형 주소** 로 불리는 논리 주소로 바뀌었고, 선형 주소는 페이징을 거쳐 **물리 주소** 가 됩니다. 

#### 보호 모드에서의 메모리 관리 방식
보호 모드는 **세그먼테이션** 과 **페이징** 을 모두 지원합니다. 보호 모드의 세그먼테이션은 리얼 모드의 세그먼테이션보다 많은 기능을 제공하며, 세그먼트 레지스터에 `세그먼트의 기준 주소`를 직접 설정하는 대신 **디스크립터 자료구조의 위치(Offset)** 를 설정하는 방식으로 바뀌었습니다. 세그먼트 레지스터의 명칭도 **세그먼트 셀렉터** 로 변경되었습니다. 

디스크립터: 메모리 영역의 정보를 저장하는 자료구조, 세그먼트에 대한 정보르르 나타내는 디스크립터는 `세그먼트 디스크립터` <br>
![ch3_10](/assets/img/posts/books/64bit/ch3_10.png) <br>

위 그림에서 볼 수 있듯이 세그먼트의 시작 어드레스와 크기, 권한(Privilege), 타입(Type) 등의 정보가 있습니다. **특권 레벨(DPL, Descriptor Privilege Level)** 은 해당 세그먼트에 접근하기 위한 최소한의 권한을 나타내고, 특권 레벨은 `0~3 사이`의 값을 가집니다. 작은 숫자일 수록 권한이 높고, 세그먼트에 접근하려면 **현재 수행 중인 특권 레벨(CPL, Current Privilege Level)** 이 적어도 디스크립터에 설정된 권한과 같거나 높아야 합니다. 권한 조건을 만족하지 못하거나, 접근하는 어드레스가 세그먼트의 크기를 넘어서는 경우 예외가 발생합니다. 

보호 모드에서 세그먼트 레지스터는 **세그먼트 디스크립터의 위치** 를 가리킵니다. 세그먼트 디스크립터는 메모리 상에 위치하는 자료구조의 일종으로 **GDT(Global Descriptor Table)** 라는 곳에 모여 있습니다. GDT는 연속된 디스크립터의 집합이며, 최대 8192개의 디스크립터를 포함할 수 있는 테이블 형태의 자료구조입니다. GDT의 위치도 프로세서에 직접 알려줘야 하는데, **GDTR(Global Descriptor Table Register)** 레지스터가 이와 관련있습니다. `16비트 GDT 크기 필드`와 `32비트 기준 주소 필드`로 구성된 자료구조의 물리 주소를 넘겨받고, 프로세서는 이걸 저장했다가 세그먼트 셀렉터를 통해 어드레스에 접근할 때 GDT의 위치를 찾는데 참조합니다.

보호 모드에서도 주소를 계산할 때 리얼 모드처럼 세그먼트 레지스터의 기준 주소에 범용 레지스터의 값을 더해서 구합니다. 이렇게 계산한게 **선형 주소** 이며 프로세서는 선형 주소를 기반으로 물리 주소를 계산하여 실제 메모리에 접근합니다. 보호 모드에서는 리얼 모드와 다르게 세그먼트의 크기를 지정할 수 있으며, 해당 세그먼트의 어드레스에 접근할 때 이를 참조하고 기준 주소에 값을 더할 때 이 크기를 넘을 수 없습니다. 다음 그림은 세그먼트 레지스터와 세그먼트 디스크립터, 선형 주소의 관계를 보여줍니다. <br>

![ch3_11](/assets/img/posts/books/64bit/ch3_11.png) <br>

리얼 모드와 다르게 선형 주소는 그대로 물리 주소가 되는게 아니라, **페이징의 입력값** 이 되며, 페이징을 안 쓰면 선형 주소가 그대로 물리 주소가 됩니다. 다음 그림은 세그먼테이션과 페이징을 통해 논리 주소를 물리 주소로 변환하는 과정입니다. <br>

![ch3_12](/assets/img/posts/books/64bit/ch3_12.png) <br>

페이징은 물리 메모리를 **페이지(Page)** 라고 불리는 일정한 크기로 나누고, 선형 주소와 물리 주소를 나눠놓은 페이지로 연결하는 방식입니다. 페이징을 사용하면 물리 메모리 크기보다 큰 영역의 선형 주소도 물리 페이지를 연결하여 더 큰 주소 공간을 쓸 수 있습니다. 또한 **같은 물리 페이지를 여러 선형 주소에 연결** 함으로써 응용프로그램끼리 공유하는 메모리를 쉽게 처리하고, 페이징 자료구조를 따로따로 생성하여 물리 메모리에 중복되지 않게 연결하여 응용프로그램의 독립적인 주소 공간을 보장할 수 있습니다. 최신 OS도 페이징의 이런 기능을 활용하여 응용 프로그램에 대한 독립된 주소 공간, 공유 메모리, 요구 페이징, 공유 라이브러리 등의 기능을 구현하고 있으며, 다음 그림은 각 응용프로그램이 4GB 크기의 독립된 주소 공간을 가질 때 이를 1GB 물리 메모리에 어떻게 연결하는지 나타내고 있습니다. <br>

![ch3_13](/assets/img/posts/books/64bit/ch3_13.png) <br>

보호 모드에서 페이징은 페이지 크기에 따라 크게 두 가지 방식으로 구분합니다.
1. 물리 메모리를 4KB로 나누고 선형 주소를 3단계로 구분
2. 물리 메모리를 4MB로 나누고 선형 주소를 2단계로 구분

3단계 페이징을 기준으로 설명을 하면, 선형 주소를 **디렉터리**, **테이블**, **오프셋** 세 부분으로 나누며 물리 메모리를 4KB 페이지로 나누어 관리하는 방식입니다.
- 디렉터리, 테이블 => `페이지 디렉터리`와 `페이지 테이블`에 있는 엔트리의 위치를 나타냅니다. 페이지 디렉터리와 테이블 역시 GDT처럼 메모리 상의 자료구조이기 때문에, **CR3 컨트롤 레지스터** 는 페이지 디렉터리의 시작 주소를 가리키며 페이지 디렉터리 엔트리의 위치 계산에 사용합니다.

페이지 디렉터리 엔트리와 페이지 테이블 엔트리는 크기가 모두 `4바이트`입니다. 페이지 크기가 최소 4KB이므로 비트 12 ~ 비트 31로 기준 주소를 나타내고 비트 11 ~ 비트 0은 속성 필드로 사용합니다. 다음 그림은 보호 모드에서의 페이지 테이블 엔트리의 구조입니다. <br>

![ch3_14](/assets/img/posts/books/64bit/ch3_14.png) <br>

여러 필드 중 **U/S(User/Supervisor) 필드** 는 해당 페이지에 접근할 수 있는 권한을 나타냅니다. 0으로 설정하면 유저 애플리케이션 레벨(3)을 제외한 모든 레벨에서 접근 가능합니다. 1로 설정하면 유저 애플리케이션 레벨 이상에서 접근 가능함을 나타내며 모든 레벨에서 접근이 가능합니다. **페이지 보호 기능** 과 **세그먼테이션의 보호 기능** 을 조합하면 메모리 모델을 단순하게 유지하면서 커널 영역과 유저 영역을 구분하는 것이 가능합니다.

선형 주소는 최상위 비트부터 디렉터리 오프셋 10비트, 테이블 오프셋 10비트, 페이지 오프셋 12비트로 구분합니다. 디렉터리와 테이블의 오프셋이 10비트이므로 페이지 디렉터리와 페이지 테이블의 엔트리 수는 총 **1024개(2^10)** 입니다. 선형 주소의 마지막에 있는 페이지 오프셋은 12비트이므로 최댓값은 4KB(2^12)이며, 12비트인 이유는 4KB 페이지의 오프셋을 나타내기 때문입니다. 페이지 디렉터리 엔트리와 페이지 테이블 엔트리 값은 각각 다음에 위치하는 페이지 테이블의 시작 주소와 페이지의 시작 주소를 나타내고, 이 값에 선형 주소의 오프셋을 더해 물리 주소를 구합니다. 다음 그림은 3단계 페이징의 어드레스 변환 과정입니다. <br>

![ch3_15](/assets/img/posts/books/64bit/ch3_15.png) <br>

1. CR3 레지스터에 설정된 값으로 페이지 디렉터리의 시작 주소를 찾기
2. 페이지 디렉터리의 시작 주소에 선형 주소의 **디렉터리 오프셋** 을 이용하여 해당 디렉터리 엔트리를 찾기(디렉터리 엔트리에 설정된 값이 페이지 테이블 시작 주소)
3. 페이지 테이블의 시작 주소에 선형 주소의 테이블 오프셋을 이용해서 해당 페이지 테이블 엔트리 찾기(페이지 테이블 엔트리에 설정된 값이 4KB 페이지의 시작 주소)
4. 페이지의 시작 주소에 선형 주소의 페이지 오프셋 값을 더해 실제 물리 주소 계산

#### IA-32e 모드의 메모리 관리
호환 모드는 보호 모드와 동작이 같기에 64비트만 알아보겠습니다. 64비트이기에 사용 가능한 최대 어드레스는 **2^64, 16EB** 입니다. IA-32e 모드의 세그먼테이션은 보호 모드와 비교하여 크게 두 가지 차이가 있습니다.

하나는 세그먼트 디스크립터에 설정된 기준 주소와 크기에 관계없이 모든 세그먼트가 기준 주소는 0, 크기는 64비트 전체로 설정되는 것입니다. 보호 모드에서 사용하던 세그먼트 디스크립터가 32비트 어드레스만 저장하게 설계되었기 때문에 64비트 어드레스 지원을 위해 강제로 값을 고정하였습니다. 따라서 IA-32e모드에서는 선형 주소를 기준 주소가 다른 여러 개의 세그먼트로 구분할 수 없습니다. 

또 다른 차이점은 호환 모드와 64비트 모드, 두 가지 서브 모드를 구분하기 위해 코드 세그먼트 디스크립터에 **L 필드(비트 21)** 가 추가된 것입니다. 이 필드가 0이면 호환 모드, 1이면 64비트 모드로 동작합니다. 다음 그림은 64비트 모드에서 주소들 간의 관계를 나타내고 있습니다. <br>

![che_16](/assets/img/posts/books/64bit/ch3_16.png) <br>

IA-32e 모드의 페이징은 보호 모드와 달리 주소 공간이 64비트로 늘어나 `PAE` 기능이 기본적으로 활성화 됩니다. 어드레스가 증가했기 변환 단계도 4KB 페이지는 5단계, 2MB 페이지는 4단계로 늘어납니다. 이 때문에 새로 추가된 테이블은 **PML4(Page Map Level 4 Table)**, **PDPT(Page-Directory-Pointer-Table)** 입니다. 다음 그림은 4KB 페이지 시스템의 5단계 방식을 나타냅니다. <br>

![ch3_17](/assets/img/posts/books/64bit/ch3_17.png) <br>

보호 모드 때와 차이가 있다면, 각 테이블의 인덱스가 9비트로 줄어들어 엔트리의 개수가 `512(2^9)`개로 줄어들었습니다. 그림을 보면 `비트 48 ~ 비트 63`이 부호 확장으로 채워져있는데, 이는 64비트 전부가 주소 표현에 사용되는게 아니라 주소 변환에 사용되는건 최대 48비트임을 의미합니다. <br>

![ch3_18](/assets/img/posts/books/64bit/ch3_18.png) <br>

프로세서가 40비트 물리 주소를 지원하는 경우에만 최대 1TB(2^40)의 물리 메모리 사용이 가능합니다. 위 그림은 IA-32e 모드의 페이지 테이블 엔트리를 나타낸 것이며 `비트 40 ~ 비트 51`이 전부 0으로 예약되어 있습니다. IA-32e 모드의 페이지 엔트리는 64비트로 늘어난 어드레스로 인해 **8바이트** 로 늘어났습니다. 하위 4바이트는 보호 모드와 구조가 같고, 상위 4 바이트는 **기준 주소 필드**, **예약된 영역**, **임의 영역**, **EXB** 로 구성됩니다. EXB 필드는 해당 페이지에서 명령어 실행을 막는, 데이터 영역의 실행 권한을 뺏는 기능을 맡습니다. 

## 4장 (부트로더)
부트 로더(Boot Loader): 512 바이트의 작은 코드 

PC가 켜진 후, OS가 실행되기 전까지 **프로세서 초기화**, **메모리와 외부 디바이스 검사, 초기화**, **부트로더 복사 및 OS 시작** 과 같은 작업이 이뤄집니다. 다음 그림은 MINT64 OS의 부팅 과정을 나타내며, PC 환경에서는 부팅 과정 중 여러 작업을 **BIOS(Basic Input/Output System)** 이 담당합니다. 참고로 POST는 Poser On Self Test입니다. <br>

![ch4_1](/assets/img/posts/books/64bit/ch3_19.png) <br>

BIOS는 일종의 펌웨어로 롬이나 플래시 메모리에 존재하며, 전원이 켜짐과 동시에 프로세서가 가장 먼저 실행합니다. 부팅 옵션, 시스템 설정을 관리하고, **인터럽트** 를 통해 BIOS에서 제공하는 기능을 사용할 수 있습니다. 

제일 중요한 기능은 **부트스트랩(Bootstrap) 코드** 입니다. BIOS에서 처음으로 제어를 넘겨받는 부분으로, 저장 매체의 가장 앞부분이나 첫 번째 섹터, **MBR(Master Boot Record)** 에 위치합니다. OS에 필요한 환경을 설정하고, OS 이미지를 메모리에 복사하는 일을 하고, 섹터 하나(512바이트)에 기능을 다 해서 공간 제약이 큽니다. BIOS는 읽어들인 512 바이트의 마지막 2바이트가 **0x55, 0xAA** 인지 검사하여 부트 로더 여부를 확인합니다. 

제작할 OS는 리얼 모드, 보호 모드, IA-32e 모드 코드를 나눠서 관리합니다. 디렉터리는 다음과 같이 구성됩니다. 
```
MINT64 (OS 이미지가 생성되는 최상위 디렉터리)
│
├── 00.BootLoader (부트 로더)
│
├── 01.Kernel32 (보호 모드 커널)
│   ├── Source (소스 파일)
│   └── Temp (빌드 과정에서 생성되는 임시 파일)
│
├── 02.Kernel64 (IA-32e 모드 커널)
│   ├── Source (소스 파일)
│   └── Temp (빌드 과정에서 생성되는 임시 파일)
│
├── 03.Application (IA-32e 모드 응용프로그램과 라이브러리 디렉터리)
│   └── 00.HelloWorld (응용프로그램별 디렉터리)
│
└── 04.Utility (OS와 관련된 유틸리티 프로그램)
    ├── 00.ImageMaker (유틸리티별 디렉터리)
    └── ...
```

### make
make는 소스 파일을 이용해서 자동으로 실행 파일 또는 라이브러리 파일을 만들어주는 빌드 관련 유틸리티입니다. 이걸 쓰려면 **각 소스 파일의 의존 관계**, **빌드 순서**, **빌드 옵션** 등에 대한 정보가 필요합니다. => makefile

디렉터리별로 계층 관계가 있는 makefile을 구성하고, 최상위 디렉터리의 makefile은 운영 모드 별 디렉터리가 복사하는 결과물을 이용하여 OS 이미지를 만들어냅니다. 

make 문법은 Target, Dependecy, Command 세 부분으로 구성됩니다.
```
Target: Dependency ...
<tab> Command
<tab> Command
<tab> ...
```
- Target: 생성할 파일
- Dependency: target 생성에 필요한 소스 파일이나 오브젝트 파일
- Command: Dependency에 관련된 파일이 수정되면 실행할 명령

또한 make는 빌드 도중 다른 make를 계층적으로 수행할 수 있습니다. `-C` 옵션을 통해 하부 디렉터리의 make를 빌드할 수 있습니다. 
```
all: output.exe

libtest.a:
    make -C Library

output.o: output.c
    gcc -c output.c

output.exe: libtest.a output.o
    gcc -o output.exe output-c -ltest -L./
```

이러한 점을 기반으로 최상위 디렉터리의 makefile을 만들 수 있습니다. 지금은 부트로더만 있어 빌드하고, 그걸 복사해서 OS 이미지를 만드는게 전부입니다. 
```
all: BootLoader Disk.img

BootLoader:
    make -C 00.BootLoader

Disk.img: 00.BootLoader/BootLoader.bin
    cp 00.BootLoader/BootLoader.bin Disk.img

clean:
    make -C 00.BootLoader clean
    rm -f Disk.img
```

부트 로더 디렉터리의 makefile은 다음과 같습니다. 어셈블리 파일을 **nasm 어셈블리어 컴파일러** 로 빌드하여 BootLoader.bin 파일을 생성합니다. 
```
all: BootLoader.bin

BootLoader.bin: BootLoader.asm
    nasm -o BootLoader.bin BootLoader.asm

clean:
    rm -f BootLoader.bin
```

### 부트로더 제작 및 테스트
부트 로더를 메모리에 정상적으로 복사하려면 한 가지: 512 바이트의 마지막 두 바이트를 **0x55, 0xAA** 로 저장하는 것만 지키면 됩니다. 00.BootLoader 디렉터리에 BootLoader.asm 파일을 생성하고 다음과 같이 입력한 후 빌드를 수행하면 최상위 디렉터리에 `Disk.img` 파일이 생성됩니다. 참고로 NASM은 **명령어 대상, 원본** 순서의 인텔 문법을 따릅니다. 
```
[ORG 0x00]      ; 코드의 시작 어드레스를 0x00으로 설정
[BITS 16]       ; 이하의 코드는 16비트 코드로 설정

SECTION .text   ; text 섹션(세그먼트)를 정의

jmp $           ; 현재 위치에서 무한 루프 수행

times 510 - ( $ - $$ ) db   0x00   ; $: 현재 라인 어드레스
                                   ; $$: 현재 섹션(.text)의 시작 어드레스
                                   ; $ - $$: 현재 섹션을 기준으로 하는 오프셋
                                   ; 510 - ( $ - $$ ): 현재부터 어드레스 510까지
                                   ; db 0x00: 1 바이트를 선언하고 값은 0x00
                                   ; time: 반복 수행
                                   ; 현재 위치에서 어드레스 510까지 0x00으로 저장
db 0x55
db 0xAA        ; 어드레스 511, 512에 두 바이트 넣어서 부트 섹터로 표기
```

make 명령을 수행하면 Disk.img 파일이 만들어집니다. 이제 qemu 에뮬레이터로 실행을 해봅시다.
```
user@Ubuntu:~/Private/Study/OS Study/64비트 멀티코어 OS 원리와 구조/source$ make
make -C 00.BootLoader
make[1]: Entering directory '/home/user/Private/Study/OS Study/64비트 멀티코어 OS 원리와 구조/source/00.BootLoader'
nasm -o BootLoader.bin BootLoader.asm
make[1]: Leaving directory '/home/user/Private/Study/OS Study/64비트 멀티코어 OS 원리와 구조/source/00.BootLoader'
cp 00.BootLoader/BootLoader.bin Disk.img
user@Ubuntu:~/Private/Study/OS Study/64비트 멀티코어 OS 원리와 구조/source$ ls
00.BootLoader  Disk.img  makefile
```

다음 명령으로 실행하면 됩니다.
```
qemu-system-x86_64 -L . -m 64 -hda Disk.img -rtc base=localtime -M pc
```

![ch4_1](/assets/img/posts/books/64bit/ch4_1.png) <br>

이렇게 무한루프가 도는 것을 볼 수 있습니다. 

#### 화면 버퍼, 제어
화면에 문자를 출력하려면 현재 동작 중인 화면 모드와 관련된 비디오 메모리의 어드레스를 알아야 합니다. 비디오 메모리는 화면 출력과 관계되어 있어 모드별로 정해진 형식에 따라 데이터를 채우면 화면에 원하는 문자나 그림을 출력하는 구조입니다. PC 부팅 후 기본적으로 설정되는 모드는 **화면 모드** 로, 어드레스는 `0xB8000`에서 시작합니다. 문자 하나는 `문자값 1바이트` + `속성값 1바이트`로 구성되어 총 메모리 크기는 4000 바이트입니다. <br>

![ch4_2](/assets/img/posts/books/64bit/ch4_2.png) <br>

속성값은 하위 4비트의 전경색과 상위 4비트의 배경색으로 구분되고, 강조, 깜빡임 등의 기능을 제공합니다. 이제 `0xB8000` 주소에 문자와 속성을 순서대로 지정하면 되는 걸 알았으니, 주소 계산을 맞춰주면 됩니다. 리얼 모드에서는 어드레스 계산을 할 때 **세그먼트 레지스터의 기준 주소 + 값** 방식으로 계산을 한다고 하였으니 편의를 위해서 세그먼트 레지스터에 0xB800을 설정하여 **세그먼트 레지스터:오프셋** 이 `0XB800:0x0000` 이 될 수 있도록 하겠습니다. 
```
mov ax, 0xB800  ; AX 레지스터에 0xB800 
mov ds, ax      ; DS 세그먼트 레지스터에 AX 복사
```

세그먼트 제리스터에 0xB800을 설정했으니, 이후 데이터에 접근하는 명령어는 물리 주소 0xB8000이 기준 어드레스로 사용됩니다. 그래서, 예를 들자면 0xB8000에 'M'을 쓰고 0xB8001에 0x4A를 쓰면 `녹색 M`을 출력할 수 있게 되는겁니다. 어셈블리어에서 어드레스에 해당하는 메모리 값을 참조할 때 `[]` 기호를 사요하며, 기호 앞에 **byte**, **word(2바이트)**, **dword(4바이트)**, **qword(8바이트)** 를 사용하여 메모리 크기를 지정합니다. 다음 코드는 화면 최상단에 녹색 M을 표시하는 코드입니다. DS 세그먼트의 값이 0xB800이므로, 0x00과 0x01을 지정하면 세그먼트 오프셋이 0xB800:0x0000, 0xB800:0x0001이 됩니다. 
```
mov byte [ 0x00 ], 'M'    
mov byte [ 0x01 ], 0x4A
```

#### 화면 정리 및 부팅 메시지
추후 작업을 위해서는 문자를 출력하기 전에 세그먼트 레지스터를 초기화하는 코드가 필요합니다. BIOS가 쓰던 값이 남아있어 엉뚱한 주소에 접근할 수도 있습니다. 본 OS에서는 `0x07C0`으로 초기화합니다. 그 이유는 BIOS가 부트 로더를 디스크에서 읽어 메모리에 복사하는 위치가 `0x7C00`이기 때문입니다. 또한 부트 로더의 코드(Code Segment)와 데이터(Data Segment)는 0x7C00부터 512 바이트 범위에 존재하기 때문에 CD, DS는 모두 0x07C0으로 설정했습니다. 

다른 세그먼트 레지스터는 MOV로 값을 바꿀 수 있지만, CS 세그먼트 레지스터는 **jmp 명령과 세그먼트 레지스터 접두사** 를 이용해야 합니다. 다음 코드는 CS, DS는 0x07C으로, ES는 화면 출력에 쓰기 위해 0xB800으로 설정하는 코드입니다.
```
SECTION .text

jmp 0x07C0:START     ; CS레지스터에 0x07C0을 복사하면서 START 레이블로 이동

START:
    mov ax, 0x07C0
    mov ds, ax

    mov ax, 0xB800
    mov es, ax
```
별다른 처리 없이 메모리에 접근하면 DS 세그먼트 레지스터가 사용되기 때문에, **세그먼트 레지스터 접두사** 를 이용하여 ES에 접근할 수 있습니다.
```
mov byte [ es: 0x00 ], 'M'
mov byte [ es: 0x01 ], 0x4A
```

화면을 깔끔하게 정리하는 제일 간단한 방법은 그냥 0xB800 어드레스부터 80*25*2 = 4000 바이트를 모두 0으로 채우는 것입니다. 본 OS에서는 속성 값은 전부 밝은 녹색인 0x0A로 처리하고 문자 부분만 0으로 채웁니다. 이 코드를 C언어로 작성한다면 다음과 같을 것입니다.
```c
int i = 0;
char* pcVideoMemory = ( char* ) 0xB8000;

while(1)
{
    pcVideoMemory[ i ] = 0;
    pcVideoMemory[ i + 1 ] = 0x0A;

    i += 2;

    if ( i >= 80 * 25 * 2 )
    {
        break;
    }
}
```

이러한 C 코드를 컴파일 한 후에 어셈블리어로 바꾸는 식으로 어셈블리 코드를 얻어낼 수 있습니다. 이때 `-c`는 컴파일만 수행하여 오브젝트 파일을 생성한다는 뜻, `-O2`는 최적화 옵션 2단계를 통해 필요없는 코드를 제거한다는 뜻입니다. 그리고 objdump를 쓸 때는 `-M intel` 옵션을 통해 인텔 문법 어셈블리를 볼 수 있습니다.
```
1. gcc -c a.c -o a.o -O2
2. objdump -d -M intel a.o
```

이런 걸 활용하면 다음과 같은 화면을 지우는 어셈블리 코드를 얻을 수 있습니다.
```
mov si, 0

.SCREENCLEARLOOP:
    mov byte [ es: si ], 0
    mov byte [ es: si + 1 ], 0x0A
    add si, 2
    cmp si, 80 * 25 * 2
    jl. .SCREENCLEARLOOP
```

이제 메시지를 출력하는 코드도 필요합니다. 다음과 같이 작성할 수 있습니다.
```
mov si, 0
mov di, 0

.MESSAGELOOP:
    mov cl, byte[ si + MESSAGE1 ]

    cmp cl, 0
    je .MESSAGEEND

    mov byte [ es: di ], cl

    add si, 1
    add di, 2

    jmp. MESSAGELOOP
.MESSAGEEND:
MESSAGE1: db 'MINT64 OS Boot Loader Start~!!', 0  ; 마지막은 0을 설정하여 루프 처리
```

지금까지 작성한 코드를 조합하여 BootLoader.asm에 넣고 빌드를 하면 부팅을 하면서 환영 메시지를 출력하는 부트 로더를 확인할 수 있습니다. 코드는 이곳에서 확인할 수 있습니다.<br>

![ch4_3](/assets/img/posts/books/64bit/ch4_3.png) <br>

## 5장 (OS 이미지 로드)
