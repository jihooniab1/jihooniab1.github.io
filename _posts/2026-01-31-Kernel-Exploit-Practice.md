---
title: "Kernel Exploit Practice"
date: 2026-01-31 00:00:00 +0900
categories: [Study]
tags: [security, linux]
permalink: /posts/Kernel-Exploit-Practice/
math: true
---

시간이 있을 때 커널에 대해 좀 더 공부도 해보고 익스플로잇에 대해서도 알아보고자 합니다. 

## 환경 설정, 준비
https://github.com/a13xp0p0v/kernel-build-containers

kctf나 원데이 등을 테스트 해보려면 다양한 커널 버전을 빌드해야 할 필요가 있을텐데, 그때 위의 `kernel-build-containers` 프로젝트를 활용한다면 의존성에 대한 신경을 덜 쓰고 필요한 버전을 편하게 빌드할 수 있습니다. 저는 kernel.org 에서 확인할 수 있는 제일 최신버전이었던 `linux-6.19-rc7`을 받아 진행하였습니다. 먼저 프로젝트를 클론부터 해줍시다.

```
user@Ubuntu:~/Private/kernel_study$ git clone https://github.com/a13xp0p0v/kernel-build-containers.git
Cloning into 'kernel-build-containers'...
remote: Enumerating objects: 858, done.
remote: Counting objects: 100% (641/641), done.
remote: Compressing objects: 100% (228/228), done.
remote: Total 858 (delta 461), reused 432 (delta 413), pack-reused 217 (from 2)
Receiving objects: 100% (858/858), 200.60 KiB | 12.54 MiB/s, done.
Resolving deltas: 100% (553/553), done.
```

https://www.kernel.org/doc/html/latest/process/changes.html

커널 빌드에 필요한 툴체인 최소 요구사항을 확인할 수 있습니다. gcc-14, clang-16이 지원되는 도커 이미지 두개를 준비해두겠습니다. Ubuntu 24.04 이미지 베이스에 맞춰서 자동으로 빌드가 됩니다.

```
user@Ubuntu:~/Private/kernel_study/kernel-build-containers$ python3 manage_images.py -b gcc-14
[+] Docker container engine is chosen (default)
[!] INFO: We need "sudo" for working with Docker containers

Build a container image providing Clang 16 and GCC 14
DEPRECATED: The legacy builder is deprecated and will be removed in a future release.
            Install the buildx component to build images with BuildKit:
            https://docs.docker.com/go/buildx/

Sending build context to Docker daemon  507.9kB
Step 1/14 : ARG UBUNTU_VERSION=default
Step 2/14 : FROM ubuntu:${UBUNTU_VERSION} AS base

...

Successfully tagged kernel-build-container:clang-16
Successfully tagged kernel-build-container:gcc-14

Current status:
--------------------------------------------
 Ubuntu | Clang  | GCC    | Docker Image ID
--------------------------------------------
 16.04  | 5      | 4.9    | -
 16.04  | 6      | 5      | -
 18.04  | 7      | 6      | -
 18.04  | 8      | 7      | -
 20.04  | 9      | 8      | -
 20.04  | 10     | 9      | -
 20.04  | 11     | 10     | -
 22.04  | 12     | 11     | -
 22.04  | 13     | 12     | -
 22.04  | 14     | 12     | -
 24.04  | 15     | 13     | -
 24.04  | 16     | 14     | a2cd48c14f11
 24.04  | 17     | 14     | -
 24.04  | 18     | 14     | -
 25.10  | 19     | 15     | -
 25.10  | 20     | 15     | -
 25.10  | 21     | 15     | -
--------------------------------------------
```

출력 디렉토리를 만들고 `build_linux.py`를 이용해 커널 설정 및 빌드를 진행합니다.
```
user@Ubuntu:~/Private/kernel_study$ mkdir -p build_out
user@Ubuntu:~/Private/kernel_study$ cd kernel-build-containers/
user@Ubuntu:~/Private/kernel_study/kernel-build-containers$ python3 build_linux.py -a x86_64 -c gcc-14 \
  -s ~/Private/kernel_study/linux-6.19-rc7 \
  -o ~/Private/kernel_study/build_out \
  -- defconfig
Docker container engine is chosen (default)
Going to build the Linux kernel for x86_64
Going to build with gcc-14
Using "/home/user/Private/kernel_study/linux-6.19-rc7" as Linux kernel sources directory
Using "/home/user/Private/kernel_study/build_out" as build output directory
Have additional arguments for 'make': defconfig
```

커맨드들은 다음과 같이 실행합니다. menuconfig를 이용해서 옵션을 설정해도 되지만, `.config` 파일을 직접 수정해도 됩니다.
```
# defconfig
python3 build_linux.py -a x86_64 -c gcc-14 \
  -s ~/Private/kernel_study/linux-6.19-rc7 \
  -o ~/Private/kernel_study/build_out \
  -- defconfig

# menuconfig (디버그 옵션 추가, 직접 .config 파일을 수정해도 됩니다)
python3 build_linux.py -a x86_64 -c gcc-14 \
  -s ~/Private/kernel_study/linux-6.19-rc7 \
  -o ~/Private/kernel_study/build_out \
  -- menuconfig

# 빌드
python3 build_linux.py -a x86_64 -c gcc-14 \
  -s ~/Private/kernel_study/linux-6.19-rc7 \
  -o ~/Private/kernel_study/build_out
```

config 파일을 직접 수정한다면 다음 옵션들을 수정하면 됩니다. 참고로 build_out/x86_64__gcc-14에 있습니다. `/`을 누른다음 필요한 키워드를 검색하고(DEBUG_INFO), 첫 번째에 있으면 1을 누르는 식으로 옵션을 들어가서 y를 누르고 설정해주면 됩니다. 다 수정하고 저장한 다음 나가면 됩니다.
```
/DEBUG_INFO → CONFIG_DEBUG_INFO=y (DWARF5 같은 옵션 선택하면 자동 활성화)
/GDB_SCRIPTS → y

/KASAN → y
/KALLSYMS → y (자동으로 켜지는 거 같기는 합니다)
```

빌드가 완료되면 이전에 만들어둔 출력 폴더에서 확인할 수 있습니다.
```
user@Ubuntu:~/Private/kernel_study/build_out/x86_64__gcc-14$ ls
arch           certs    include   kernel    modules.builtin          net       source      virt            vmlinux.o
block          crypto   init      lib       modules.builtin.modinfo  scripts   System.map  vmlinux         vmlinux.unstripped
build_log.txt  drivers  io_uring  Makefile  modules.order            security  tools       vmlinux.a
built-in.a     fs       ipc       mm        Module.symvers           sound     usr         vmlinux-gdb.py
```

https://github.com/bata24/gef

gdb는 위에 있는 kernel-gef를 쓰는게 개인적으로 편했던 것 같습니다. 

또한 리눅스 VM을 부팅하려면 루트에 마운트되어 디렉토리 형태로 동작할 수 있는 **disk image** 가 필요합니다. ext4 같은 실제 파일 시스템 이미지를 사용할 수도 있지만, 간단하게 커널만 테스트하려면 **cpio** 형식의 아카이브를 **initramfs** 로 사용할 수 있습니다. CPIO는 **copy in and out** 을 의미하며 파일들을 줄줄이 이어 붙인 아카이브 포맷입니다. 먼저 BusyBox로 기본적인 형태의 `rootfs.cpio`를 만들어줍시다. BusyBox는 리눅스에서 쓰는 ls, cat, mount 등의 명령어를 하나의 파일 안에 다 넣은 프로그램입니다. 그 후 심볼릭 링크를 bin 폴더에 만들어 쓰기 편하게 만드는 과정입니다. 

```
mkdir rootfs
cd rootfs

mkdir -p bin sbin etc proc sys usr/bin usr/sbin dev

wget https://busybox.net/downloads/binaries/1.35.0-x86_64-linux-musl/busybox -O bin/busybox

chmod +x bin/busybox
cd bin
for i in $(./busybox --list); do ln -s busybox $i; done

ls -l ls
```

`ls -> busybox` 이런 식으로 나오면 됩니다. 이제 init 스크립트를 추가해줍니다. 커널이 부팅되자마자 실행할 스크립트로 이게 없으면 커널이 작동하지 않습니다. 
```
cat << 'EOF' > init
#!/bin/sh
ㅉ
mount -t proc none /proc
mount -t sysfs none /sys
mount -t devtmpfs none /dev

export PATH="/bin:/sbin:/usr/bin:/usr/sbin"

echo 0 > /proc/sys/kernel/kptr_restrict

setsid cttyhack /bin/sh

poweroff -f
EOF
```

init 스크립트에 실행 권한도 부여해줍니다. 
```
chmod +x init
```

그 후에 cpio 형식의 파일로 묶어주면 됩니다.
```
find . -print0 | cpio -o --format=newc --null | gzip > ../rootfs.cpio.gz
```

qemu 스크립트는 아래와 같이 구성하면 됩니다. 파일 경로는 각자 환경에 맞게 고쳐써야 합니다.
```
#!/bin/sh
qemu-system-x86_64 \
    -m 512M \
    -nographic \
    -kernel build_out/x86_64__gcc-14/arch/x86_64/boot/bzImage \
    -initrd rootfs.cpio.gz \
    -append "console=ttyS0 loglevel=7 oops=panic panic=1 nopti nokaslr" \
    -no-reboot \
    -cpu host \
    -enable-kvm \
    -smp 1 \
    -net nic,model=virtio \
    -net user \
    -S \
    -s
```

`-enable-kvm`의 기능을 제대로 사용하려면 그룹에 **kvm** 을 추가해야 합니다.
```
user@Ubuntu:~/Private/kernel_study$ ls -l /dev/kvm
crw-rw----+ 1 root kvm 10, 232 Feb  1 21:25 /dev/kvm
user@Ubuntu:~/Private/kernel_study$ groups
user adm cdrom sudo dip plugdev users lpadmin
```
이런 식으로 kvm 그룹에 속해있지 않다면 **sudo usermod -aG kvm $USER** 이걸 실행하고 재부팅을 해줍니다.

뒤에 있는 `-S -s`는 디버깅을 위해 추가하는 옵션입니다. 추가하고 스크립트를 실행하면 실행되지 않고 멈춰있는데, 이 때 **gdb vmlinux** 를 실행하고 **target remote: 1234** 를 하면 커널 디버깅이 시작됩니다. <br>

![k1](/assets/img/posts/Study/kernel_ex_1.png) <br>

커널 모듈을 로드하는 방법은 여러가지가 있지만 
1. rootfs에 포함시킨 다음 init 스크립트로 로드하는 방법
2. 쉘에서 insmod나 modeprobe를 통해 로드하는 방법
이 있습니다.

먼저 Makefile을 만들어주겠습니다. `KBUILD_DIR`은 커널이 빌드된 디렉토리를 가리켜야 커널의 빌드 시스템인 kbuild를 빌려서 빌드할 수 있습니다. Makefile 구조는 다음과 같습니다.

```
obj-m := vuln.o
KERNEL_SRC := $(shell pwd)/../linux-6.19-rc7
KBUILD_OUTPUT := $(shell pwd)/../build_out/x86_64__gcc-14
CFLAGS_vuln.o := -O0

all:
	$(MAKE) -C $(KERNEL_SRC) O=$(KBUILD_OUTPUT) M=$(shell pwd) modules
	cp vuln.ko $(shell pwd)/../rootfs/root/

clean:
	$(MAKE) -C $(KERNEL_SRC) O=$(KBUILD_OUTPUT) M=$(shell pwd) clean
```

이런 식으로 구성하였습니다. 취약한 드라이버 코드는 LK01 코드를 가져왔습니다. 코드는 다음과 같습니다.  make를 할 때는 커널과 컴파일러 정보도 맞춰줘야 해서 

```
sudo docker run --rm -it -v .:/work -w /work kernel-build-container:gcc-14 bash
```

이 커맨드로 커널 빌드할 때 썼던 컨테이너를 들어간 다음에 모듈을 빌드하였습니다. 또한 rootfs/root 경로로 복사를 해두었습니다. 이제 init 스크립트를 수정하여 부팅과 동시에 모듈이 로드가 되도록 하겠습니다. init 스크립트에 두 줄을 추가하면 됩니다.

```
insmod /root/vuln.ko
mknod -m 666 /dev/holstein c `grep holstein /proc/devices | awk '{print $1;}'` 0
```

두번째 커맨드를 통해 `/dev/holstein`을 만들어주어야 유저 스페이스와 커널 드라이버가 통신하는 인터페이스를 구성할 수 있습니다.

커널 모듈을 디버깅하고 싶으면 `add-symbol-file` 명령어로 디버거에게 심볼을 인식시켜주어야 합니다. 디버거는 vmlinux 심볼만 알고 있고 모듈에 대한 정보는 없기 때문입니다. 

```
/ # cat /proc/modules
vuln 32768 0 - Live 0xffffffffc000e000 (O)
```
`cat /proc/modules`를 하면 커널이 로드된 모듈 목록을 읽어서 보여줍니다. vuln 모듈이 올라간 주소를 확인할 수 있고, 이 주소를 갖고 vuln.ko 파일의 심볼을 직접 로드하면 됩니다. 

```
gef> add-symbol-file ../../vuln_module/vuln.ko 0xffffffffc000e000
add symbol table from file "../../vuln_module/vuln.ko" at
	.text_addr = 0xffffffffc000e000
Reading symbols from ../../vuln_module/vuln.ko...
```

이제 이렇게 하면 `module_read` 같은 함수에 브레이크 포인트를 잡을 수 있습니다. 커널 모듈이 로드가 되면, 유저 공간에서 `/dev/holstein`에 대해 쓰기 작업을 하는 방법으로 데이터를 보내고, 읽기 작업을 하는 방식으로 데이터를 읽을 수 있게 됩니다. 

어떤 c 코드 익스플로잇을 작성하고 실행하려면 일단 커널 안에 넣어주어야 합니다. 아래와 같은 스크립트를 구성하면 쉽게 익스를 넣고 rootfs.cpio를 만들 수 있습니다. 참고로 컴파일을 할 때는 `-static` 을 넣고 컴파일을 해주어야 커널 안에서도 잘 실행이 됩니다. busybox 기반 환경에서는 동적 라이브러리가 없어 동적 링킹된 바이너리는 실행이 안 됩니다. 참고로 CTF와 같이 네트워크를 활용할 수 없는 환경에서는 입력을 줄 때 `Base64`를 많이 활용하는데, gcc로 컴파일 한 파일은 크기가 너무 크다는 문제가 있습니다. 이 때 **musl-gcc** 를 활용한다면 파일 크기를 대폭 감소시킬 수 있습니다. 

```
sudo apt install musl-tools

musl-gcc exploit.c -o exploit -static
``` 

이렇게 빌드를 하고 rootfs에 넣어주면 됩니다. 편의를 위해 아래와 같은 스크립트를 구성할 수 있습니다.

```
#!/bin/sh
musl-gcc exploit.c -o exploit -static
mv exploit rootfs/root
cd rootfs && find . -print0 | cpio -o --format=newc --null | gzip > ../rootfs.cpio.gz
```

커널을 부팅하면 /root 경로에 exploit 실행 파일이 있는 것을 확인할 수 있습니다. 

## pawnyable
### Stack Overflow
