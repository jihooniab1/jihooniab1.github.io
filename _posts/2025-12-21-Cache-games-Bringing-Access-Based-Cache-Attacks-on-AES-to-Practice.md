---
title: "Cache Games – Bringing Access-Based Cache Attacks on AES to Practice"
date: 2025-12-21 00:00:00 +0900
categories: [Papers]
tags: [side channel]
permalink: /posts/Cache-games-Bringing-Access-Based-Cache-Attacks-on-AES-to-Practiced/
math: true
---

# Summary for Cache Games – Bringing Access-Based Cache Attacks on AES to Practice

# Index
- [1. Introduction](#introduction)
- [2. Preliminaries](#preliminaries)
- [3. The Flush+Reload Technique](#the_flush_reload_technique)
- [4. Attacking GnuPG](#attacking_gnupg)
- [5. Mitigation Techniques](#mitigation_techniques)

# Introduction
**부채널 공격(Side channel attacks)** 은 암호 시스템의 구현 레벨에 대한 공격들입니다. 특정 연산의 시간 소모량, 전력 소모량, 전자기파 방출 등을 통해 정보를 유출시킵니다. 특히, 지난 몇년간 마이크로 프로세서의 **캐시 접근 메커니즘(cache access mechanism)** 을 기반으로 한 여러 부채널 공격들이 지난 몇 년간 활발하게 연구 되었습니다. 이러한 부채널 공격들은 `시간 기반(time-driven)`, `추적 기반(trace-driven)`, `접근 기반(access-driven)` 공격으로 나뉩니다.

**시간 기반 공격** 에서 공격자는 `whole encryption`과 같은 특정 연산을 수행하는 데 걸리는 총 시간을 관찰할 수 있으며, 이 시간 정보는 암호화 과정에서 발생한 캐시 히트와 미스의 횟수에 대한 정보를 노출시킵니다. **추적 기반 공격** 에서는 암호화 작업 중 캐시 활동의 profile을 얻어, 암호 알고리즘이 수행한 메모리 접근 중 어떤 것이 캐시 히트를 일으켰는지 **추론(infer)** 할 수 있습니다. 마지막으로 **접근 기반 공격** 은 암호 알고리즘이 어떤 캐시 세트(cache set)에 접근했는지 파악할 수 있게 하여 암호 알고리즘의 요소들을 추론할 수 있습니다.

이러한 공격들의 기본 시나리오는 다음과 같습니다: 동일한 캐시를 사용하는 **두 프로세스(스파이 프로세스 S, 타겟 보안 프로세스 V)** 가 동시에 실행되는 상황을 가정합니다. V가 실행되면서 캐시 상태를 변화시키도록 만들게 한 다음, S가 본인 메모리에 접근하는 시간을 측정하는데, 이 시간은 캐시 상태에 따라 달라집니다. 이러한 측정을 통해 S는 V가 접근한 메모리 위치를 추론할 수 있습니다. 

이 논문은 새롭고, 실제로 효율이 높은 AES에 대한 접근 기반 공격을 보여줍니다. 주요 특징으로는 아주 약한 가정(assumption)으로도 작동한다는 것이 있습니다. 이 공격이 작동하려면 공격자가 공격 전에 victim 머신과 동일한 테스트 머신을 보유하고 있어야 합니다. 테스트 머신은 `168,000` 회의 암호화로부터 두 개의 인공 신경망을 위한 학습 샘플을 생성하는 데 사용됩니다. 그런 다음 이 신경망들은 임의의 플랫폼에서 학습되어야 합니다. 이제 공격을 수행하려면 victim 머신에서 non-privileged 스파이 프로세스를 실행만 하면 됩니다. IPC나 I/O, 네트워크 연결 등을 필요로 하지 않습니다. 본 논문의 공격은 다음 특징들을 가집니다.

1. 기존 연구와 달리 스파이 프로세스는 비밀 키를 복구하기 위해 평문, 암호문이나 확률 분포를 알 필요 없습니다.
2. 암호문을 전혀 모르는 상태에서 키와 평문을 복구하는 방법을 제시합니다.
3. OpenSSL에서도 사용되는 `compressed table`을 활용하는 AEA의 경우 암호화 과정의 처음과 마지막 라운드가 식별될 수 없지만, 이 경우에도 작동합니다.
4. 128비트 AES에 대한 공격을 완전하게 구현했으며, 실시간으로 키 복구가 가능할 정도로 효율적입니다.
5. 공격의 핵심은 victim 프로세스의 모든 단일 메모리 접근을 평균적으로 관찰할 수 있는 **스파이 프로세스** 입니다. 캐시 히트와 미스에 대한 높은 관찰 정밀도는 리눅스 커널의 **Completely Fair Scheduler** 의 동작을 악용하는 새로운 기법을 통해 달성됩니다. 

# Preliminaries
먼저 CPU 캐시의 동작을 간단하게 정리하고, AES의 구현에 대해 설명합니다.

## The CPU Cache and its Side Channels
먼저 CPU 캐시의 동작을 설명하고, 어떻게 부채널 공격에 의해 파훼될 수 있는지 알아보겠습니다. CPU 캐시는 **주메모리와 CPU 사이에 위치하는 빠른 메모리** 이며, 크기는 수백 kb부터 수 mb까지 다양합니다. 일반적으로 CPU가 접근하려는 데이터는 이미 캐시에 있는게 아니라면 먼저 캐시에 로드가 됩니다. 이미 캐시에 있다면 이걸 **캐시 히트(cache hit)** 라고 부르며, 이 경우 데이터는 거의 지연 없이 CPU로 전달이 됩니다. 그러나 캐시 미스(cache miss)가 발생하면 캐시 히트에 비해 100배 가량의 지연이 발생합니다. 이를 통해 CPU 캐시는 캐시 히트와 미스를 모니터링할 수 있는 공격자에게 메모리 접근에 대한 정보를 누출하게 됩니다.

더 자세하게 들어가려면 **n-way associative cache**(주메모리의 각 물리 주소가 캐시 내 n개의 다른 곳에 매핑 가능)가 어떻게 작동하는지 이해해야 합니다. 캐시는 `$2^a$` 개의 캐시 세트로 구성되며 각 세트는 n개의 **캐시 라인(cache line)** 을 가집니다. 캐시 라인은 캐시가 처리할 수 있는 가장 데이터 단위로 현대 아키텍처에서는 64, 128바이트의 크기가 일반적입니다. `주소 A = (A_max, ... , A_0)의 데이터`를 담고 있는 캐시 라인을 찾기 위해, 캐시 라인이 항상 $2^b$ 바이트를 저장하므로 A의 최하위 b비트를 무시할 수 있습니다. 그 다음 a비트, 즉 `(A_(a+b-1), ... , A_b)` 는 세트 인덱스(Set Index)로 사용됩니다. 이제 어떤 주소 A에서 데이터를 요청하면, 캐시 로직은 A에 해당하는 태그를 식별된 캐시 세트의 모든 태그와 비교하여 원하는 캐시 라인을 찾거나 캐시 미스를 알립니다. 같은 캐시 세트에 매핑되는 주소들은 캐시에서 **에일리어싱(aliasing)** 된다고 합니다. 서로 다른 에일리어싱 주소에 대한 `n번`을 넘는 메모리 접근이 발생하면, 캐시 로직은 캐시 라인을 **축출(evict)** 해야 합니다. 즉 수정된 데이터는 RAM에 다시 기록되고 캐시 라인은 재사용됩니다. 

이러한 내용을 바탕으로 공격자가 멀티태스킹 OS에서 정보를 유출하는 시나리오가 최소 2개가 있음을 알 수 있습니다. victim 프로세스 V, 스파이 프로세스 S가 동시에 실행되고 있고 캐시가 S에 의해 초기화되는 상황을 가정합시다. V가 어느정도 실행된 후, OS가 S로 switch 합니다.

- S와 V가 물리적으로 같은 주메모리를 공유한다면(두 가상 메모리가 RAM의 같은 페이지에 매핑) S는 먼저 캐시 전부를 flush하면서 시작합니다. CPU에 대한 제어를 얻어온 후 S는 메모리 주소로부터 읽어오면서 지연 시간을 체크하여 캐시 히트, 미스를 모니터링할 수 있습니다. 히트는 V의 메모리 접근 위치를 나타냅니다. 
- S와 V가 물리적으로 같은 메모리를 공유하지 않는다면, 일반적으로 **캐시 에일리어싱 메모리** 에 접근할 수 있습니다. 이 경우 S는 캐시를 어떤 데이터 D로 초기화하고, replacement strategy를 활용해 개별 캐시 라인 상태를 준비합니다. 다시 스케줄링되면 S는 다시 D에 접근해 어떤 데이터가 캐시에서 축출되었는지 확인합니다. 이를 통해 S는 V의 메모리 접근에 대한 정보를 추론할 수 있습니다.

본 논문에서 다루는 타겟은 `OpenSSL Library on Linux`로, 실제로는 물리 메모리 한 곳에만 위치하며 이를 사용하는 프로세스들의 가상 메모리로 매핑이 됩니다. 따라서 본 노눈에서는 **공유 메모리 시나리오** 를 다루는데, 여기서 V는 각각 `$2^d$` 바이트 크기의 `$2^c$` 개의 항목을 가진 룩업 데이블을 사용하고, 비밀 변수를 인덱스로 사용하여 접근합니다. 또한 **캐시 라인 정렬** 이라는 자연스러운 가정도 합니다. 룩업 테이블의 메모리 시작 지점이 캐시 라인 경계에 해당한다고 가정하는건데, 대부분의 컴파일러에서는 큰 구조체에 대해서 이렇게 처리합니다. 

앞서 다룬 정보 유출을 활용하면 S는 V가 접근하는 메모리 위치를 캐시 라인 단위까지 추론할 수 있습니다. 즉, 캐시 라인 크기가 $2^b$ 바이트일 때 S는 비밀 인덱스의 `l = c - max(0,b-d)` 비트를 재구성할 수 있습니다. 본 공격에서는 이 l 비트부터 전체 키를 재구성합니다.

## AES - The Advanced Encryption Standard
AES는 대칭형 블록 암호화 기법입니다. AES는 항상 16 바이트 크기의 블럭 