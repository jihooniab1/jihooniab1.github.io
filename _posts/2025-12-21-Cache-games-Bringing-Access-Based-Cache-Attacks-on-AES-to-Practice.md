---
title: "Cache Games – Bringing Access-Based Cache Attacks on AES to Practice"
date: 2025-12-21 00:00:00 +0900
categories: [Papers]
tags: [security, side channel]
permalink: /posts/Cache-games-Bringing-Access-Based-Cache-Attacks-on-AES-to-Practiced/
math: true
---

# Summary for Cache Games – Bringing Access-Based Cache Attacks on AES to Practice

## Index
- [1. Introduction](#introduction)
- [2. Preliminaries](#preliminaries)
- [3. Breaking AES Given Ideal Measurements](#breaking-aes-given-ideal-measurements)

## Introduction
**부채널 공격(Side channel attacks)** 은 암호 시스템의 구현 레벨에 대한 공격들입니다. 특정 연산의 시간 소모량, 전력 소모량, 전자기파 방출 등을 통해 정보를 유출시킵니다. 특히, 지난 몇년간 마이크로 프로세서의 **캐시 접근 메커니즘(cache access mechanism)** 을 기반으로 한 여러 부채널 공격들이 지난 몇 년간 활발하게 연구 되었습니다. 이러한 부채널 공격들은 `시간 기반(time-driven)`, `추적 기반(trace-driven)`, `접근 기반(access-driven)` 공격으로 나뉩니다.

**시간 기반 공격** 에서 공격자는 `whole encryption`과 같은 특정 연산을 수행하는 데 걸리는 총 시간을 관찰할 수 있으며, 이 시간 정보는 암호화 과정에서 발생한 캐시 히트와 미스의 횟수에 대한 정보를 노출시킵니다. **추적 기반 공격** 에서는 암호화 작업 중 캐시 활동의 profile을 얻어, 암호 알고리즘이 수행한 메모리 접근 중 어떤 것이 캐시 히트를 일으켰는지 **추론(infer)** 할 수 있습니다. 마지막으로 **접근 기반 공격** 은 암호 알고리즘이 어떤 캐시 세트(cache set)에 접근했는지 파악할 수 있게 하여 암호 알고리즘의 요소들을 추론할 수 있습니다.

이러한 공격들의 기본 시나리오는 다음과 같습니다: 동일한 캐시를 사용하는 **두 프로세스(스파이 프로세스 S, 타겟 보안 프로세스 V)** 가 동시에 실행되는 상황을 가정합니다. V가 실행되면서 캐시 상태를 변화시키도록 만들게 한 다음, S가 본인 메모리에 접근하는 시간을 측정하는데, 이 시간은 캐시 상태에 따라 달라집니다. 이러한 측정을 통해 S는 V가 접근한 메모리 위치를 추론할 수 있습니다. 

이 논문은 새롭고, 실제로 효율이 높은 AES에 대한 접근 기반 공격을 보여줍니다. 주요 특징으로는 아주 약한 가정(assumption)으로도 작동한다는 것이 있습니다. 이 공격이 작동하려면 공격자가 공격 전에 victim 머신과 동일한 테스트 머신을 보유하고 있어야 합니다. 테스트 머신은 `168,000` 회의 암호화로부터 두 개의 인공 신경망을 위한 학습 샘플을 생성하는 데 사용됩니다. 그런 다음 이 신경망들은 임의의 플랫폼에서 학습되어야 합니다. 이제 공격을 수행하려면 victim 머신에서 non-privileged 스파이 프로세스를 실행만 하면 됩니다. IPC나 I/O, 네트워크 연결 등을 필요로 하지 않습니다. 본 논문의 공격은 다음 특징들을 가집니다.

1. 기존 연구와 달리 스파이 프로세스는 비밀 키를 복구하기 위해 평문, 암호문이나 확률 분포를 알 필요 없습니다.
2. 암호문을 전혀 모르는 상태에서 키와 평문을 복구하는 방법을 제시합니다.
3. OpenSSL에서도 사용되는 `compressed table`을 활용하는 AES의 경우 암호화 과정의 처음과 마지막 라운드가 식별될 수 없지만, 이 경우에도 작동합니다.
4. 128비트 AES에 대한 공격을 완전하게 구현했으며, 실시간으로 키 복구가 가능할 정도로 효율적입니다.
5. 공격의 핵심은 victim 프로세스의 모든 단일 메모리 접근을 평균적으로 관찰할 수 있는 **스파이 프로세스** 입니다. 캐시 히트와 미스에 대한 높은 관찰 정밀도는 리눅스 커널의 **Completely Fair Scheduler** 의 동작을 악용하는 새로운 기법을 통해 달성됩니다. 

## Preliminaries
먼저 CPU 캐시의 동작을 간단하게 정리하고, AES의 구현에 대해 설명합니다.

### The CPU Cache and its Side Channels
먼저 CPU 캐시의 동작을 설명하고, 어떻게 부채널 공격에 의해 파훼될 수 있는지 알아보겠습니다. CPU 캐시는 **주메모리와 CPU 사이에 위치하는 빠른 메모리** 이며, 크기는 수백 kb부터 수 mb까지 다양합니다. 일반적으로 CPU가 접근하려는 데이터는 이미 캐시에 있는게 아니라면 먼저 캐시에 로드가 됩니다. 이미 캐시에 있다면 이걸 **캐시 히트(cache hit)** 라고 부르며, 이 경우 데이터는 거의 지연 없이 CPU로 전달이 됩니다. 그러나 **캐시 미스(cache miss)** 가 발생하면 캐시 히트에 비해 100배 가량의 지연이 발생합니다. 이를 통해 CPU 캐시는 캐시 히트와 미스를 모니터링할 수 있는 공격자에게 메모리 접근에 대한 정보를 누출하게 됩니다.

더 자세하게 들어가려면 **n-way associative cache**(주 메모리의 각 물리 주소가 캐시 내 n개의 다른 곳에 매핑 가능)가 어떻게 작동하는지 이해해야 합니다. 캐시는 $2^a$ 개의 캐시 세트로 구성되며 각 세트는 n개의 **캐시 라인(cache line)** 을 가집니다. 캐시 라인은 캐시가 처리할 수 있는 가장 작은 데이터 단위로 현대 아키텍처에서는 64, 128바이트의 크기가 일반적입니다. 주소 $A = (A_{max}, ... , A_0)$의 데이터를 담고 있는 캐시 라인을 찾기 위해, 캐시 라인이 항상 $2^b$ 바이트를 저장하므로 A의 최하위 b비트를 무시할 수 있습니다. 그 다음 a비트, 즉 $(A_{a+b-1}, ... , A_b)$ 는 세트 인덱스(Set Index)로 사용됩니다. 이제 어떤 주소 A에서 데이터를 요청하면, 캐시 로직은 A에 해당하는 태그를 식별된 캐시 세트의 모든 태그와 비교하여 원하는 캐시 라인을 찾거나 캐시 미스를 알립니다. 같은 캐시 세트에 매핑되는 주소들은 캐시에서 **에일리어싱(aliasing)** 된다고 합니다. 서로 다른 에일리어싱 주소에 대한 `n번`을 넘는 메모리 접근이 발생하면, 캐시 로직은 캐시 라인을 **축출(evict)** 해야 합니다. 즉 수정된 데이터는 RAM에 다시 기록되고 캐시 라인은 재사용됩니다. 

이러한 내용을 바탕으로 공격자가 멀티태스킹 OS에서 정보를 유출하는 시나리오가 최소 2개가 있음을 알 수 있습니다. victim 프로세스 V, 스파이 프로세스 S가 동시에 실행되고 있고 캐시가 S에 의해 초기화되는 상황을 가정합시다. V가 어느정도 실행된 후, OS가 S로 switch 합니다.

- S와 V가 물리적으로 같은 주메모리를 공유한다면(두 가상 메모리가 RAM의 같은 페이지에 매핑) S는 먼저 캐시 전부를 flush하면서 시작합니다. CPU에 대한 제어를 얻어온 후 S는 메모리 주소로부터 읽어오면서 지연 시간을 체크하여 캐시 히트, 미스를 모니터링할 수 있습니다. 히트는 V의 메모리 접근 위치를 나타냅니다. 
- S와 V가 물리적으로 같은 메모리를 공유하지 않는다면, 일반적으로 **캐시 에일리어싱 메모리** 에 접근할 수 있습니다. 이 경우 S는 캐시를 어떤 데이터 D로 초기화하고, replacement strategy를 활용해 개별 캐시 라인 상태를 준비합니다. 다시 스케줄링되면 S는 다시 D에 접근해 어떤 데이터가 캐시에서 축출되었는지 확인합니다. 이를 통해 S는 V의 메모리 접근에 대한 정보를 추론할 수 있습니다.

본 논문에서 다루는 타겟은 `OpenSSL Library on Linux`로, 실제로는 물리 메모리 한 곳에만 위치하며 이를 사용하는 프로세스들의 가상 메모리로 매핑이 됩니다. 따라서 본 노눈에서는 **공유 메모리 시나리오** 를 다루는데, 여기서 V는 각각 $2^d$ 바이트 크기의 $2^c$ 개의 항목을 가진 룩업 데이블을 사용하고, 비밀 변수를 인덱스로 사용하여 접근합니다. 또한 **캐시 라인 정렬** 이라는 자연스러운 가정도 합니다. 룩업 테이블의 메모리 시작 지점이 캐시 라인 경계에 해당한다고 가정하는건데, 대부분의 컴파일러에서는 큰 구조체에 대해서 이렇게 처리합니다. 

앞서 다룬 정보 유출을 활용하면 S는 V가 접근하는 메모리 위치를 캐시 라인 단위까지 추론할 수 있습니다. 즉, 캐시 라인 크기가 $2^b$ 바이트일 때 S는 비밀 인덱스의 `l = c - max(0,b-d)` 비트를 재구성할 수 있습니다. 본 공격에서는 이 l 비트부터 전체 키를 재구성합니다.

### AES - The Advanced Encryption Standard
AES는 대칭형 블록 암호화 기법입니다. AES는 항상 16 바이트 크기의 블럭 $(x_0 ... x_F)$을 4 x 4 행렬로 다루면서 처리합니다. 이 행렬들을 대문자 문자들로 나타내고, column vector들을 볼드체의 밑줄친 소문자로 나타냅니다. <br>

![c_1](/assets/img/posts/papers/cachegames_1.png) <br>

단일 바이트들인 `x_i`는 $GF(2^8)$의 원소로 취급이 됩니다. GF는 **갈루아 체** 라는 수학적 구조로, $GF(2^8)$는 0부터 255까지, 1바이트로 표현 가능한 값으로 이루어진 집합을 의미합니다. 이때 이 장에서의 덧셈을 $\oplus$, 곱셈을 $\bullet$ 방식으로 나타냅니다. 덧셈은 `bitwise XOR`과 동등합니다. 곱셈을 위한 `irreducible polynomial(기약 다항식)`은 $x^8 + x^4 + x^3 + x + 1$로 주어집니다. 이 필드에서 곱셈은 두 값을 다항식으로 변환하여 곱한 뒤, **결과를 8비트 내에 가두기 위해** 특정 다항식으로 나눈 나머지를 구하는 방식으로, 이 때 나누는 divisor가 저 다항식입니다. 이 연산들을 행렬과 벡터에 적용할 때도 통상적인 의미 그대로 사용합니다. 보통 행렬 곱셈을 할 때 `곱하기 더하기`를 반복하는데, 이 때 위의 연산을 사용한다는 의미입니다. 

현재 state를 라운드 키로 XOR 하는게 아니라면, AES의 단일 라운드는 세가지 연산을 사용합니다:
- ShiftRows: 행렬 $X$의 각 행을 순환 이동(Cyclic Shift) 시킴
- SubBytes: `고정된 역변환 가능한(invertible) 규칙`에 따라 행렬의 각 항목을 바이트 단위로 치환(Substitution) 함
- MixColumns: 행렬에 고정된 행렬 M을 곱함

AES의 각 라운드 첫 번째 step에서는 행렬 X에 대해 다음과 같은 재배열을 수행합니다. 행렬 $\tilde{X}$의 열들을 $(\tilde{x_0} \; \tilde{x_1} \; \tilde{x_2} \; \tilde{x_3})$ 이렇게 나타냅니다. <br>

![c_2](/assets/img/posts/papers/cachegames_2.png) <br>

그 다음 step에서는 행렬 $\tilde{X}$의 모든 바이트들이 AES 표준에 정의된 **S-box**에 따라 치환됩니다. 이 치환을 $s(\cdot)$으로 표기합니다. 즉, $SubBytes(\tilde{{X}})$ 연산은 행렬 전체에 s를 적용하는 $s(\tilde{X})$와 같으며, 형태는 다음과 같습니다. <br>

![c_3](/assets/img/posts/papers/cachegames_3.png) <br>

또는 간단하게 $s(\tilde{X}) \; = \; (s(\tilde{x}_0)\;s(\tilde{x}_1)\;s(\tilde{x}_2)\;s(\tilde{x}_3))$로 나타냅니다.

마지막으로, MixColumns 연산에서 상태 행렬은 `상수 행렬 M`과 곱해집니다. <br>

![c_4](/assets/img/posts/papers/cachegames_4.png) <br>

X의 경우와 마찬가지로 행렬 M의 열들을 굵은 글씨로 축약하여 표기하고, 바이트 값들은 16진수로 읽어야 합니다. 앞의 내용들을 바탕으로, i번째 라운드의 라운드 키를 $K_i$, 평문을 $X_0$, 암호문을 $X_{r+1}$이라고 할 때, AES를 다음과 같은 점화식으로 쓸 수 있습니다. <br>

$$X_{i+1} =
\begin{cases}
X_i \oplus K_i & i = 0 \\
M \bullet s(\tilde{X}_i) \oplus K_i & 0 < i < r \\
s(\tilde{X}_i) \oplus K_i & i = r
\end{cases}$$

128비트 AES 구현에서 라운드 수인 r은 10입니다. 키 생성 과정을 자세하게 다루지는 않지만, 다음 라운드 키 $K_{i+1}$은 이전 키 $K_i$로부터 다음 과정을 통해 얻어진다는 점만 언급합니다.
1. Nonlinear transformation: 암호화와 동일한 S-box 사용
2. Cyclic shift: 바이트 벡터 회전
3. XOR with Rcon: $(2^i, 0, 0, 0)$과 XOR 수행 (여기서 2는 $GF(2^8)$의 원소 $x$를 의미)

### How to Implement AES
AES는 $GF(2^8)$에서의 계산에 크게 기반을 두고 있는 반면, 대부분 CPU의 ALU는 오직 정수에 대한 산술만을 제공합니다. 배포된 코드의 빠른 참조 구현은 AES를 32비트 기계어 단어(machine words)에 대한 기본 연산들만으로 수행할 수 있도록 재구성했습니다. OpenSSL의 구현은 여기서 더 나아가 중복성을 활용해 룩업 테이블(Lookup Table)에 필요한 공간을 절반으로 줄여 2KB의 메모리를 절약합니다. 이 기술들을 AES의 내부 라운드 하나를 예로 들어 설명하겠습니다. 

라운드 전후의 상태 행렬을 각각 $X$와 $Y$, 라운드 키를 $K$라고 할 때, 다음 관계가 성립합니다.$$Y = M \bullet s(\tilde{X}) \oplus K \quad \text{...(2)}$$이를 풀어서 첫 번째 열 $y_0$에 대해 쓰면 다음과 같습니다.$$y_0 = m_0 \bullet s(x_0) \oplus m_1 \bullet s(x_5) \oplus m_2 \bullet s(x_A) \oplus m_3 \bullet s(x_F) \oplus k_0 \quad \text{...(3)}$$($y_1, y_2, y_3$도 유사한 방식으로 전개됩니다.)

여기서 $GF(2^8)$ 상에서의 비용이 높은 곱셈 연산을 피하기 위해, 모든 잠재적인 결과를 미리 계산한 테이블 $T_0, \dots, T_3$를 준비합니다. 즉, $T_i[x] = m_i \bullet s(x)$로 정의합니다. 이를 이용하면 위의 식을 오직 **테이블 조회(Lookup)**와 XOR 연산만으로 다시 쓸 수 있습니다.$$y_0 = T_0[x_0] \oplus T_1[x_5] \oplus T_2[x_A] \oplus T_3[x_F] \oplus k_0$$

각 $T_i$는 4바이트 크기의 엔트리 256개($2^8$)를 가지므로 총 4KB의 메모리가 필요합니다. 하지만 이 테이블들은 매우 중복적입니다. 예를 들어 $T_1$은 $T_0$를 바이트 단위로 회전시킨 것과 같습니다. 따라서 하나의 큰 테이블 $T$를 만들어 엔트리 값을 두 번 반복($abcd \to abcdabcd$)시켜 저장해 두면, 적절한 오프셋으로 접근하는 것만으로 회전 연산 없이 모든 $T_i$ 값을 얻을 수 있습니다. 이는 메모리를 2KB로 줄여 L1 캐시 효율을 높여줍니다.

마지막으로, 마지막 라운드는 MixColumns 연산이 없기 때문에 구현 방식이 조금 다릅니다.$s(\tilde{X})$를 위한 별도의 룩업 테이블을 사용하는 방법기존 $T$ 테이블에서 곱해지는 값이 '1'인 위치를 참조하여 재사용하는 방법첫 번째 방법은 새로운 테이블로의 메모리 접근이 발생하므로 공격자가 이를 통해 암호화의 종료 시점(마지막 라운드)을 식별할 수 있는 취약점이 됩니다. 반면, 두 번째 방법(OpenSSL 0.9.8 등에서 사용)은 메모리 접근 패턴이 이전 라운드들과 구별되지 않아 이러한 부채널 공격을 방어할 수 있습니다.

## Breaking AES Given Ideal Measurements
이 섹션에서는 **이상적인 캐시 측정(ideal cache measurements)** 가정 하에 어떻게 AES 비밀키 전체를 복구할 수 있는지 보여줍니다. 본 연구에서는 스파이 프로세스가 victim 프로세스의 **모든 캐시 접근을 올바른 순서대로** 관찰할 수 있다고 가정하는데, 이러한 제한적인 가정을 통해 복구 기법 설명을 좀 더 쉽게 설명할 수 있습니다. 

### Using Accesses from Two Consecutive Rounds
[cpu cache](#the-cpu-cache-and-its-side-channels) 부분에서 설명하였듯이, 룩업 테이블로의 메모리 접근을 기록하면 비밀 인덱스의 $l$ 비트를 추론할 수 있습니다. 룩업 테이블이 $2^d$ 바이트 크기의 $2^c$개의 엔트리를 가지고 있다고 하고, 캐시 라인이 $2^b$ 바이트를 가지고 있을 수 있다면, $l$은 $c - \min(0, b - d)$로 계산됩니다.

따라서 우리는 $x$의 상위 $l$ 비트를 나타내기 위해 $x^*$라는 표기법을 도입하고, 이를 벡터로도 확장합니다. 우리의 경우(OpenSSL) $c=8$, $d=3$입니다. 만약 $b=6$(64바이트 캐시 라인)이라고 가정하면, 우리는 **$l = 5$**를 얻게 되고 결과는 다음과 같습니다. <br>

$$\begin{pmatrix}
11001000_2 \\
00010011_2 \\
10010011_2 \\
00101010_2
\end{pmatrix}^*
=
\begin{pmatrix}
11001_2 \\
00010_2 \\
10010_2 \\
00101_2
\end{pmatrix}$$

설명의 편의를 위해, 그리고 현재 CPU들에서의 높은 관련성 때문에, 논문의 나머지 부분에서 **$b=6$로 고정** 을 합니다. 그러나 b가 6이 아니어도 공격은 작동하며, $b<6$라면 더 높은 효율성을, $b>6$라면 낮은 효율성을 가집니다(b가 6보다 크면 캐시 접근을 통해서 비밀 인덱스에 대한 정보 유출이 줄어듦, 캐시 라인이 작아질 수록 데이터가 조금씩 들어가서 해상도가 높아진다).

이 표기와 $$Y = M \bullet s(\tilde{X}) \oplus K$$ 이 식을 사용하면 다음 방정식들이 성립한다는 것을 쉽게 알 수 있습니다. $$k_i^* = y_i^* \oplus (M \bullet s(\tilde{x}_i))^* \quad 0 \leq i \leq 3 \quad \text{...(4)}$$ 

이 방정식들 각각은 **partial key-column candidate(부분 키-열 후보)** 들의 집합 $\mathcal{K}_i \subseteq \{0, 1\}^{4l}$를 정의합니다. 구체적으로, 우리는 측정된 $\tilde{x}^*_i$가 식 (4)를 만족하는 완전한 4바이트 벡터 $\tilde{x}_i$ 로 완성될 수 있게 하는 모든 원소 $k^*_i \in {0,1}^{4l}$들로 구성되도록 $\mathcal{K}_i$를 정의합니다. 이 집합들은 $\tilde{x}_i$의 가능한 모든 값 $2^{32-4l}$개를 순회하는 방식으로 계산될 수 있습니다. 

$\mathcal{K}_i$의 **집합의 크기(원소의 개수, cardinality)** 는 모든 $\tilde{x}^*_i$에 대해 일정하지 않다는 것이 드러났습니다. 그러나 어떤 $\tilde{x}_i^*$가 `partial key-column candidate`가 될 확률에 대해 논의할 필요가 있기에, 우리는 $\tilde{x}^*_i$가 $\{0, 1\}^{4l}$ 공간에 균등하게 분포한다고 가정함으로써 $\mathcal{K}_i$의 기댓값(expected cardinality)을 계산합니다. <br>

![c_5](/assets/img/posts/papers/cachegames_5.png) <br>

표 1은 모든 가능한 l 값에 대한 $\mathcal{k}_i$의 기대 크기를 보여줍니다. 표의 마지막 열은, 무작위한 $\tilde{x}^*_i$에 대해 무작위한 $k^*_i \in {0, 1}^{4l}$가 부분 키-열 후보가 될 확률 $p_l$을 제공합니다. $1 \le l \le 3$인 경우, 모든 $\tilde{x}^*_i$가 식 (4)를 만족하는 $\tilde{x}_i$로 완성될 수 있음을 알 수 있습니다. 따라서, 이 경우($l \le 3$)에는 이 접근법이 비밀키 $K$에 대한 아무런 정보도 제공하지 못합니다. 반대의 극단적인 상황은 $l = 8$일 때, 즉 우리가 피해자 프로세스가 접근하는 룩업 테이블의 **정확한 엔트리(항목)**를 모니터링할 수 있을 때 발생합니다. 이 경우에는 연속된 두 라운드의 상태 $X, Y$만으로도 키를 복구할 수 있습니다. 흥미로운 경우는 **$3 < l < 8$**인 구간으로, 여기서는 비밀키에 대한 제한된 양의 정보를 얻을 수 있는데, 다음 내용에서 이를 다룰 예정입니다. 

### Using Accesses from Continuous Streams
이전 섹션들의 관찰들은 일반적으로 공격자에 의해 직접적으로 악용되기 힘든데, OpenSSL 같은 **압축된 테이블을 사용하는 AES 구현** 은 어디서 한 라운드가 끝나고 어디서 다음 라운드가 시작하는지 정확히 결정하기 어렵기 때문입니다. 대신에 공격자는 victim 프로세스가 수행하는 **연속적인 메모리 접근(continuous stream of memory accesses)** 를 모니터링할 수 있고, 우리는 M회의 encryption 관측으로부터 어떻게 키가 재구성될 수 있는지 보일 것입니다.

각 라운드 내에서의 메모리 접근 순서는 구현에 의존적이지만, 단일 라운드들은 항상 직렬로 수행되며, 각 라운드는 항상 16번의 테이블 조회를 필요로 한다는 점을 기억하자. 따라서, 식 (4)가 연속된 라운드의 상태들을 관계 짓기 때문에, 한 라운드의 첫 번째 접근 이후 처음 31번의 메모리 접근 내에서 모든 4개의 방정식(즉, $i = 0, \dots, 3$에 대해)을 완성하는 것이 항상 가능합니다.

이제 공격자가 `160M + 31 = N + 31`개의 메모리 접근을 관찰할 수 있다고 가정해봅시다(AES 128은 10라운드, 각 라운드는 16번 조회. 즉, 암호화 한번에 160회 접근). 양적으로 **M번의 전체 암호화에 해당하는 접근** 이 관찰되었다는 뜻이지만, 관찰된 첫 번째 접근이 암호화의 시작점일 필요는 없습니다. 남은 31개는 $(M + 1)$번째 암호화에 속합니다. 거시적인 관점에서, 라운드의 시작과 끝을 식별할 수 없는 문제를 우회하기 위해 다음 단계들을 수행합니다.
- 처음 관찰된 N개의 메모리 접근 하나하나를 전부 AES 라운드의 시작인 것처럼 취급
- 잠재적 시작점들 각각에 대해서 key-column candidate 집합을 계산. 그리고 ${0, 1}^{4l}$의 각 원소가 이 집합들에 얼마나 자주 포함되는지 빈도를 계산.
- 이 빈도들로부터 특정 원소가 진짜 키의 올바른 부분일 확률을 도출.

더 정확히 말하면, $N$개의 잠재적 시작점 어디에서든 부분 키 후보 집합 $\mathcal{K}_i$ ($i=0 \dots 3$)를 계산하고, 가능한 모든 $k^*_i$ 값이 그 집합 $\mathcal{K}_i$에 포함되는 횟수를 셉니다. 앞서 언급한 바와 같이(식 4를 풀려면 32개 데이터 필요), 그리고 마지막 31개의 추가 데이터 덕분에, 우리는 이 $N$개의 시점 중 어디서든 식 (4)를 완성하기에 충분한 관측치를 갖게 됩니다. 

간단한 관찰을 통해, 만약 $k^*_i$가 $z_{k^*_i}$개의 서로 다른 라운드에서 사용된 라운드 키의 올바른 $i$번째 열의 잘린 부분(상위 비트)이라면, $k^*_i$는 적어도 $z_{k^*_i} M$번은 후보 집합 $\mathcal{K}_i$의 원소가 된다는 것을 알 수 있습니다.(역주: 여기서 $M$은 관찰한 암호화 횟수입니다. 진짜 키는 암호화가 일어날 때마다 올바른 타이밍(진짜 라운드 시작점)에서는 무조건 식을 만족시키므로, 최소한 암호화 횟수만큼은 후보로 등장해야 한다는 뜻입니다.) 달리 말하면, 우리는 $f_i(k^*_i) \ge z_{k^*_i} M$ (빈도가 최소한 이 값 이상임)이라는 식을 얻습니다. 나머지 $N - z{k^*_i} M$개의 잘못된 시작점들(wrong starting points) 각각에 대해서는, $k^*_i$가 확률 $p_l$로 $\mathcal{K}_i$에 나타난다고 가정할 수 있습니다. 이는 잘못된 $x^*_i, y^*_i$ 값들에 대해 식 (4)를 푸는 것이 올바른 키에 대한 어떤 정보도 유출하지 않아야 하기 때문입니다. 비록 $x^*_i, y^*_i$가 완전히 무작위가 아니라 이어지는 라운드의 올바른 값들과 **겹치는 부분(overlapping parts)**이라 할지라도 말입니다. 이전 섹션에서와 마찬가지로, 이 가정은 우리의 목적을 위해 실험적으로 충분히 만족된다는 것이 입증되었습니다.

$n$개의 샘플과 확률 $p$에 대한 이항 분포를 $\text{Binomial}(n, p)$라고 표기할 때, 우리는 이제 $f_i(k^*_i)$의 속성들을 다음과 같이 기술할 수 있습니다.

$$f_i(k^*_i) \sim \text{Binomial}(N - z_{k^*_i} M, p_l) + z_{k^*_i} M$$
$$E[f_i(k^*_i)] = N p_l + z_{k^*_i} M(1 - p_l)$$
$$V[f_i(k^*_i)] = (N - z_{k^*_i} M)p_l(1 - p_l)$$

이 식들로부터, 라운드 키에 실제로 등장하는 모든 $k^*_i$는 빈도표(frequency table)에서 **피크(Peak, 솟아오른 부분)**를 형성한다는 것을 알 수 있습니다. 이제 우리는 이 피크들과, 라운드 키에 등장하지 않는 후보들이 형성하는 거대한 바닥(floor) 사이의 차이를 측정할 수 있습니다. 이 **차이(Signal)**는 관찰된 암호화 횟수 $M$에 따라 선형적으로(linearly, 비례해서) 증가합니다. 반면, **표준편차(Noise의 흔들림)**는 오직 $M$의 제곱근($\sqrt{M}$)에 비례해서 증가합니다 (여기서 $N$은 $M$의 상수배임에 유의). 따라서, 암호화 횟수가 증가할수록, 피크들은 바닥으로부터 더 잘 분리될(구별될) 것입니다. $f_i(k^*_i)$와 베이즈 정리(Bayes Theorem)를 사용함으로써, 주어진 $k^*_i$가 피해자 프로세스의 키 스케줄에 실제로 존재했을 사후 확률(a posteriori probabilities) $q_i(k^*_i)$를 계산하는 것이 이제 가능해집니다.

### Key Search
이전 섹션에서 언급했듯이, 키 후보 $k^*_i$가 올바른 키 스케줄의 일부라면 빈도표에서 **피크(솟아오른 값)**를 형성할 것이며, 반면 다른 모든 $k^*_i$는 높은 확률로 그렇지 않을 것입니다. 따라서 다음으로 우리는 부분 키-열 후보들의 **집합(Set)**에 **점수(Score)**를 부여하고, 높은 점수를 가진 집합을 찾는 데 관심을 둡니다. 높은 점수를 가진 집합은 원본 키에서 유래했을 가능성이 매우 높기 때문입니다. 우리는 후보 집합에 점수를 매기기 위해 평균 로그 확률(mean log-probability) 방식을 선택했습니다. $$h(S) = \frac{1}{|S|} \sum_{k^*_i \in S} \log q_i(k^*_i)$$ 즉, 후보들의 집합 $S$에 대해, 점수는 위와 같이 계산됩니다. (집합 $S$에 속한 모든 후보들의 로그 확률을 더해서 개수로 나눈 값) 우리는 그러한 집합 $S$의 모든 원소가 자신이 후보로 있는 **키 스케줄 상의 위치 정보로 태그(tag)** 되어 있다고 가정합니다. 

우리는 이제 올바른 미지의 키를 찾기 위해 반복적으로(iteratively) 탐색을 수행합니다. 대략적으로 말하자면, 우리의 기법은 전체 키 스케줄에 있는 모든 부분 키-열(partial key-columns)들에 대한 평균 로그 확률(mean log-probability)이 최대가 되는 $K$를 출력합니다.(즉, 전체적으로 봤을 때 점수가 가장 높은 키 조합을 정답으로 내놓는다는 뜻입니다.) 아래에 기술된 알고리즘은 키 스케줄에서 **좋은 점수(확실한 증거)를 가진 항목 하나를 고정(fixing)** 하는 것으로 시작합니다. 그러고 나서, 키의 추가적인 부분을 더할 때마다, AES의 키 스케줄(구조적 특성)은 **다른 부분들도 고정하도록 강제(forces)** 합니다. 아래 그림을 참고할 수 있습니다(거기서 $t_i$는 특별한 의미가 없는 임시 변수들을 나타냅니다). 우리 알고리즘은 이제 높은 점수를 내포하는 키 스케줄 $K$가 발견될 때까지 이 단계들을 반복적으로 수행합니다. 

우리는 $k^i_3$에 대한 부분 키-열 후보들, 즉 $i$번째 라운드 키의 **마지막 열(3번 열)** 을 탐색하는 것으로 시작합니다. 이를 위해, 우리는 $k^*_3$의 모든 가능한 값들에 대한 싱글톤(원소가 하나인 집합)들을 포함하는 **힙(Heap)** 을 초기화하고, 이들을 점수 $h({k^*_3})$에 따라 정렬합니다. (참고: 점수가 높은 후보가 힙의 꼭대기에 오게 됩니다.) 

힙의 가장 위에 있는 원소 ${k^i_3}$를 꺼내서(remove), 이를 $k^{i+1}_3$의 후보로 해석되는 모든 부분 키-열 후보 $k^*_3$들과 결합합니다. 즉, **$(i+1)$번째(다음) 라운드 키의 마지막 열** 후보들과 결합하는 것입니다. 아래 그림에서 볼 수 있듯이, ${k^i_3}$를 $k^{i+1}_3$ 후보와 결합하는 것은 라운드 키들 간의 관계 때문에 **$k^{i+1}_2$를 고정(fix)하는 것을 또한 내포(imply)** 합니다. (참고: 이것이 앞서 말한 "강제된다"는 부분입니다. 두 개를 정하면 나머지 하나가 공짜로 결정됩니다.) 우리는 $k^{i+1}_3$ 후보와 그로 인해 연관된 모든 값들을 ${k^i_3}$에 추가하는 이 연산을 $\uplus$ 기호로 표기합니다. 그 결과로 생성된 모든 집합 ${k^i_3} ] {k^{i+1}_3}$들은 그들의 점수에 따라 다시 힙에 추가됩니다. 이 단계는 힙의 최상위 원소가 $k^i_3$와 $k^{i+3}_3$에 대한 후보를 동시에 포함하지 않을 때까지(즉, 4라운드 분량이 모일 때까지) 유사하게 반복 적용됩니다.

만약 힙의 최상위 원소 $S$가 이미 $k^{i+3}_3$에 대한 후보를 포함하고 있다면, 우리는 이전과 같이 모든 가능한 $k^{i+4}_3$ 선택지에 대해 조합 $S \uplus {k^{i+4}_3}$를 계산합니다. (참고: $i$부터 $i+3$까지 모았으니, 이제 다음 라운드인 $i+4$로 넘어가는 상황입니다.) 그러나 AES 키 스케줄의 비선형적 구조(nonlinear structure) 때문에, 우리는 이제 $t^{i+3}$을 $k^{i+3}_3$의 부분들과 관계 지을 수 있고, 그 비선형성이 어떤 $i$에 대해(즉, 그림 2에서 $S$의 고정된 위치에 대해) 해결될 수 있는지 확인할 수 있습니다. 만약 해결되지 않는다면(규칙에 어긋난다면), 우리는 그 조합 $S \uplus {k^{i+4}_3}$를 버리고(discard), 그렇지 않으면 힙에 추가합니다. 우리는 $k^{i+5}_3$에 대해서도 유사하게 진행합니다. (확실하게 하기 위해 한 단계 더 수행)

이제 힙의 최상위 원소 $S$가 이미 $k^i_3$부터 $k^{i+5}_3$까지의 후보들을 포함하고 있다고 합시다. (충분한 길이의 체인이 형성됨) 아래 그림에서 볼 수 있듯이, 한 라인(연속된 순서)에 있는 4개의 $k^j_i$가 주어지면 전체 키 스케줄을 채울 수 있습니다. (역주: AES 키는 128비트(=4개의 32비트 워드)이므로, 연속된 4개의 열을 알면 마스터 키를 아는 것과 같습니다.) $S$가 주어졌을 때, 우리는 이미 그러한 '라인'의 80비트($4 \text{열} \times 4 \text{바이트} \times l=5 \text{비트}$)를 고정했습니다. 게다가, 키 스케줄의 비선형성(S-Box 규칙)을 해결하는 과정에서 그중 24비트를 추가로 산출해 냅니다. (역주: S-Box 방정식을 만족시키려면 하위 3비트 중 일부가 특정 값으로 고정되어야 하기 때문입니다.) 즉, 잠재적 키의 오직 24비트만이 미지수(unknown)로 남습니다. (계산: 128 - 80 - 24 = 24) 우리는 이제 키 스케줄 내 $S$의 각 가능한 위치에서, 이 $2^{24}$가지 가능성에 대해 무차별 대입(brute-force) 탐색을 수행합니다. 여기서 일반적으로 주어진 위치에 대해 비선형성의 해(solution)는 기껏해야 1개라는 점을 주목하세요. 해가 1개보다 많은 드문 경우에는, 그들 각각에 대해 다음 단계들을 수행합니다. $k^i_3, \dots, k^{i+3}_3$의 모든 가능한 완성(빈칸 채우기)에 대해, 우리는 전체 키 스케줄을 계산합니다. 즉, 모든 라운드 키를 다 만든 뒤, 전체 키 스케줄에 대한 점수(score)를 계산합니다. 우리는 가장 높은 점수를 가진 집합에 해당하는 키를 그 점수와 함께 저장합니다. (이것이 최종 범인입니다.) 

우리는 키 스케줄의 **대칭성(symmetry)**이 우리 공격을 소프트웨어로 실제로 구현할 때 효율성을 높이는 데 사용될 수 있음을 언급해 둡니다. 예를 들어, 어떤 고정된 "기준선(base line)"을 가진 삼각형 $S$는 수직으로 뒤집힌(flipped vertically) 삼각형과 동일한 점수 $h(S)$를 갖습니다. 이러한 이유로, 우리 공격의 처음 두 단계에서는 이 삼각형들 중 하나에 대해서만 점수를 계산하면 됩니다.