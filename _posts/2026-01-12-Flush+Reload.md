---
title: "Flush+Reload: A High Resolution, Low Noise, L3 Cache Side-Channel Attack"
date: 2026-01-12 00:00:00 +0900
categories: [Papers]
tags: [security, side channel]
permalink: /posts/Flush+Reload/
math: true
---

# Summary for Flush+Reload: A High Resolution, Low Noise, L3 Cache Side-Channel Attack

## Introduction
시스템의 메모리 점유율(memory footprint)을 줄이기 위해, 시스템 소프트웨어는 프로세스들 사이에 동일한 메모리 페이지를 공유합니다. 이러한 공유는 페이지의 출처(source)에 기반하거나, 같은 내용을 담고 있는 페이지를 탐색해서 병합(coalescing)하는 방식에 기반할 수 있습니다(리눅스의 KSM-Kernel Same-page Merging). 서로 신뢰하지 않는 프로세스 간의 **격리** 를 유지하기 위해, 시스템은 공유된 페이지에 `read only`나 `copy-on-write` 등을 적용하는 하드웨어 메커니즘에 의존합니다. 프로세서는 프로세스가 공유 페이지의 내용을 바꾸지 못하도록 보장하지만, 다른 방식의 inter-process 간섭을 차단하는 데는 실패하기도 합니다. 

이 간섭의 한가지 유형은 여러 프로세스가 **프로세서 캐시를 공유** 하기 때문에 발생합니다. 어떤 프로세스가 메모리에 있는 공유 페이지에 접근하면, 그 접근한 메모리 위치의 내용이 캐시에 저장됩니다(cached). [이전 논문](/posts/Cache-games-Bringing-Access-Based-Cache-Attacks-on-AES-to-Practiced/)은 이러한 특성을 활용하여 공유 메모리 페이지에 대한 접근 정보를 추출하는 부채널 공격을 소개했습니다. `clflush` 명령어로 감시 대상 메모리 위치를 캐시에서 강제로 축출(evict)한 다음에, victim 프로세스가 잠깐 실행되게 두고 나서 데이터가 캐시에 들어있는지 확인하는 방식입니다. 본 연구에서는 `clflush` 명령어가 **Last-Level-Cache (LLC)** 를 포함한 모든 캐시 레벨에서 메모리 라인을 축출하는 것을 확인하였고, 이에 기반하여 기존의 연구를 발전시킨 **FLUSH+RELOAD** 공격을 설계하였습니다(cross core, cross VM 가능). 

FLUSH+RELOAD 공격의 특징은 다음과 같습니다.

1. 이전 공격들 대부분은 특정 **캐시 세트(cache set)** 와 같은 더 큰 범위에 대한 접근을 식별한 반면, 이 공격은 특정 **메모리 라인(memory line)** 에 대한 접근을 정확히 식별합니다. 이는 적은 오탐과 높은 정밀도 등으로 이어집니다. 

2. 또한 이 공격은 LLC(동일한 프로세서 다이 위의 여러 코어가 공유)에 집중하기에 다른 코어의 victim도 공격할 수 있습니다. 이전에도 LLC를 노리는 공격들이 있었으나 해상도가 매우 낮았습니다.

FLUSH+RELOAD 공격을 GnuPG의 RSA implementation에 대해 두 가지 다른 시나리오에서 테스트하였습니다. (i)same OS 시나리오, 같은 OS 위에서 victim과 spy 실행 (ii)cross-VM 시나리오, 물리적으로는 같은 머신 위에 있는 분리된 가상머신에서 실행. 두 시나리오 모두 90%가 넘는 높은 정밀도를 보였습니다. 

## Preliminaries
### Page Sharing
**content-aware sharing** 을 사용할 때, 동일한 페이지들은 해당 페이지의 내용이 로드되는 **디스크 위치** 에 의해 식별됩니다. 이는 주요 운영체제들이 대부분 사용하는 방식이며, 같은 executable file들을 실행 중인 프로세서 사이에서 코드 영역을 공유할 때나, 공유 라이브러리를 사용할 때 쓰입니다. **Content-based page sharing** 또는 **memory deduplication** 은 더 공격적인 형태의 페이지 공유 방식으로, 시스템은 active memory 전체를 스캔하여 서로 관련 없는 페이지들이라도 내용이 같으면 하나로 병합합니다. 

메모리 페이지는 서로 신뢰하지 않는 프로세스들 사이에서도 공유될 수 있기 때문에, 시스템은 공유된 내용을 수정하지 못하도록 보호해야합니다. 이를 위해 시스템은 **Copy-on-Write** 방식으로 공유 페이지를 매핑합니다. CoW 페이지에 대한 쓰기 시도 시, 쓰기 가능한 복사본을 만들어 작업을 하는 방식입니다. 이를 통해서 공유 페이지가 수정되지 못하도록 보호는 할 수 있지만, 복사 과정에서 일어나는 지연 시간이 존재하여 잠재적 정보 유출로 이어질 수도 있습니다. 

### Cache Architecture
메모리 페이지 공유 외에도, 동일한 프로세서에서 실행되는 프로세스들은 **프로세서 캐시** 를 공유합니다. 현대 프로세서들은 다수의 캐시들로 구성된 **캐시 계층(cache hierarchy)** 구조를 채택하고 있으며, 아래 그림은 Core i5-3470 프로세서의 캐시 구조를 나타내고 있습니다. **코어(core)** 라고 불리는 processing unit이 4개가 있고, 각 코어는 64KB-L1(32-data, 32-inst), 256KB-L2 캐시가 코어마다 있고, 4개의 코어가 6MB 크기의 L3 캐시를 공유하고 있는 모습입니다. <br>

![f1](/assets/img/posts/papers/flush_reload_1.png) <br>

캐시에서 메모리의 기본 단위는 **라인(line)** 이며, 라인은 고정된 바이트 수를 포함합니다. 캐시는 다수의 **cache set** 로 구성되며, 각 세트는 고정된 수의 캐시 라인들을 저장하는데, 하나의 세트 안에 들어있는 캐시 라인의 수를 **Cache Associativity** 라고 합니다. 각 메모리 라인은 자신이 배정된 캐시 세트 내에 있는 **어떤 캐시 라인에도** 저장될 수 있습니다. Core i5-3470 프로세서에서 캐시 라인 크기는 64 바이트이며, L1과 L2는 8-way, L3는 12-way associative입니다. 

현대 인텔 프로세서에서 LLC의 중요한 특징은 **inclusive cache** 라는 점으로, LLC는 하위 캐시 레벨(L1, L2)에 저장된 모든 데이터의 복사본을 포함하고 있습니다. 결과적으로, LLC에서 데이터를 `flush` 하거나 `evict` 하면 해당 데이터는 다른 캐시 레벨에서도 제거됩니다. 

같은 캐시라도 레벨에 따라서 코어에서 거리가 멀고 용량이 클수록(L3) 가까운 캐시 레벨에서 가져오는 것보다 시간이 오래 걸립니다. 그리고 이러한 타이밍 차이는 부채널 공격에서 악용되어 왔습니다. 공격자는 이를 위해 victim이 작업을 하기 전에 먼저 캐시를 **알려진 상태(known state)** 로 설정합니다(clflush로 비우기, 가득 채워두기 등). 그 후 victim이 작업을 수행하는 데 걸리는 `실행 시간`을 측정하거나, victim의 작업이 끝난 후 `공격자가 데이터에 접근하는 시간`을 측정하는 방식을 통해 victim의 작업에 대한 내용을 추론합니다. 

캐시 사이드 채널 선행 연구 대부분은 victim과 spy가 같은 코어 내에서 실행되는 상황에 의존합니다. 그 이유 중 하나는, 많은 공격들이 spy가 공격을 하는 동안 victim의 중단을 요구했기 때문인데, 이를 위해 spy가 victim을 block 할 수 있도록 스케줄러에 대한 공격과 결합되기도 했었습니다. 또 다른 이유는 **코어 간에 공유되지 않는** L1 cache에 집중하기 때문입니다. LLC는 크기가 커서 작은 캐시에 비해 known state로 설정하는데 시간이 오래 걸리고, OS가 사용하는 가상 메모리가 **메모리 주소와 캐시 세트 간의 매핑** 을 가려버립니다. 게다가 대부분의 메모리 활동은 L1에서 처리가 되기에 LLC 활동으로 추출할 수 있는 정보에는 한계가 있습니다. 

### RSA
RSA는 암호화와 서명을 지원하는 **공개키 암호화** 시스템으로, 암호화 시스템은 다음 단계를 통해 생성됩니다.
- 두 소수 p, q를 무작위로 선택하고 n = pq 계산
- 공개 지수 e를 선택하는데, GnuPG는 65537을 사용합니다.
- 비밀 지수 $d \equiv e^{-1} \pmod{(p-1)(q-1)}$를 계산합니다.

생성된 암호화 시스템의 구성 요소는 다음과 같습니다.
- 공개키는 쌍 $(n, e)$입니다.
- 비밀키(개인키)는 세 쌍 $(p, q, d)$입니다.
- 암호화 함수는 $E(m) = m^e \pmod n$입니다.
- 복호화 함수는 $D(c) = c^d \pmod n$입니다.

**CRT-RSA** 는 복호화 함수 구현을 위해 흔히 사용되는 최적화 기법으로, 비밀키 $d$를 $d_p = d \pmod{p - 1}$과 $d_q = d \pmod{q-1}$ 두 부분으로 나누고, 메시지의 두 부분인 $m_p = c^{d_p} \pmod p$와 $m_q = c^{d_q} \pmod q$를 계산합니다. 그 후 Garner의 공식을 사용하여 $m_p$와 $m_q$로부터 $m$을 계산합니다: $$h = (m_p - m_q)(q^{-1} \pmod p) \pmod p$$ $$m = m_q + hq$$

암호화 및 복호화 함수를 계산하기 위해, 1.4.14 버전 이전의 GnuPG와 1.5.3 버전 이전의 관련 libgcrypt는 **square-and-multiply 거듭제곱 알고리즘** 을 사용합니다. Square-and-multiply는 지수 $e$의 이진 표현 비트들을 스캔하여 $x = b^e \pmod m$을 계산합니다.$e$의 이진 표현이 $2^{n-1}e_{n-1} + \dots + 2^0e_0$으로 주어졌을 때, square-and-multiply는 공식 $x_{i-1} = x_i^2 b^{e_{i-1}}$을 사용하여 $x_i = b^{\lfloor e/2^i \rfloor} \pmod m$을 만족하는 중간값들의 수열 $x_{n-1}, \dots, x_0$를 계산합니다. 아래 코드는 square-and-multiply의 의사 코드를 보여줍니다. <br>

![f2](/assets/img/posts/papers/flush_reload_2.png) <br>

구현에서 볼 수 있듯이, 지수 계산은 일련의 제곱(square) 및 곱셈(multiply) 연산으로 구성되며, 각각의 뒤에는 모듈러 감산(mudolo reduce)이 이어집니다. 이 연산 순서는 지수의 비트들과 직접적으로 대응이 되는데, 해당 순서 내에서 `square-reduce-multiply-reduce`가 나타나는 경우는 값이 1인 비트에 해당합니다. 곱셈이 뒤따르지 않는 `square-reduce`가 나타나는 경우는 값이 0인 비트에 해당합니다. 결과적으로, 알고리즘의 실행을 추적할 수 있는 spy 프로세스는 지수를 복원할 수 있습니다. GnuPG는 CRT-RSA 최적화를 사용하므로, 스파이 프로세스는 $d_p$와 $d_q$만을 추출할 수 있습니다. 그러나 임의의 메시지 $m$에 대해, $(m - m^{ed_p})$는 $p$의 배수가 되기에, **$d_p$나 $d_q$만 알아내면** 암호화를 무력화 할 수 있습니다. 

## The FLUSH+RELOAD Technique
FLUSH+RELOAD 기법은 spy와 victim 프로세스 간의 페이지 공유에 의존하는 기법입니다. 공유된 페이지를 통해, spy는 특정 메모리 라인이 전체 캐시에서 축출되었음을 확인할 수 있고, 이를 통해 메모리에 대한 접근을 관찰합니다. 

한번의 공격은 3개의 단계로 구성됩니다. 첫 번째 단계에서는 모니터링 대상 메모리 라인이 **전체 캐시에서 제거(flush)** 됩니다. 그 후 spy는 세 번째 단계 전에 victim에게 메모리 라인에 접근할 시간을 주고 대기합니다. 세 번째 단계에서 spy는 메모리 라인을 **reload** 하는데, 만약 대기하는 동안 victim이 접근을 했다면 reload는 빠르게 이뤄지고, 만약 접근하지 않았다면, 해당 라인을 메모리(DRAM)에서 가져와야 하므로 reload 시간이 길어집니다. 아래 그림의 (A)와 (B)는 victim의 접근에 따른 타이밍을 보여줍니다. (B)가 victim이 access를 한 경우입니다.<br>

![f3](/assets/img/posts/papers/flush_reload_3.png) <br>

그림의 (C)에서 볼 수 있듯이, victim의 access가 spy의 reload 단계와 겹칠 수도 있습니다. 이 경우, victim의 access가 **cache fill** 을 유발하지 않고, victim은 spy에 의해 캐시된 데이터를 사용하게 되어 spy는 victim의 access를 놓치게 됩니다. 리로드 작업이 victim의 접근과 부분적으로 겹치는 경우도 비슷합니다. 그림의 (D) 상황에서는, victim이 데이터를 기다리는 동안 reload가 시작되는데, 이 경우 리로드 작업은 victim의 접근 덕분에 이득을 보게 되어 메모리에서 통째로 가져와야 할 때보다는 빠르게 종료되지만, 캐시에서 로드하는 것보다는 오래 걸릴 수 있습니다. 

Victim의 접근은 spy 프로세스 코드 실행과는 독립적이라 대기 시간을 늘리면 overlap으로 인해 access를 놓칠 확률은 줄여주지만, 공격의 세밀도가 떨어질 수 있습니다. 에러율을 높이지 않으면서 해상도를 개선하는 한 가지 방법은, 반복문과 같이 **빈번하게 발생하는 메모리 접근** 을 노리는 것입니다. 이 방법이 개별 접근들을 구별(discern) 하지는 못하더라도 그림의 (E)에서 보여주듯이 접근 자체를 놓칠 가능성은 낮습니다. 또한 프로세서의 여러 최적화 기법들(speculative execution, data prefetching 등)로 인해 오탐이 발생할 수 있는데, 공격 결과를 분석할 때 공격자는 이 점을 인지하고 이를 걸러내기 위한 전략을 수립해야 합니다. <br>

```c
int probe(char *adrs) {
    volatile unsigned long time;

    asm __volatile__ (
        " mfence \n"
        " lfence \n"
        " rdtsc \n"
        " lfence \n"
        " movl %%eax, %%esi \n"
        " movl (%1), %%eax \n"
        " lfence \n"
        " rdtsc \n"
        " subl %%esi, %%eax \n"
        " clflush 0(%1) \n"
        "=a" (time)
        "c" (adrs)
        "%esi", "%edx");
    return time < threshold;
}
```

이 코드는 메모리 주소의 데이터를 읽는 데 걸리는 시간을 측정하고, 그 후 해당 메모리 라인을 축출합니다. 이 측정은 `asm` 커맨드 내의 인라인 어셈블리 코드로 구현됩니다. 어셈블리 코드는 하나의 입력, **주소** 를 받는데 이는 레지스터 `%ecx`에 저장됩니다("c" (adrs) 부분). 코드가 주소를 읽는 데 걸리는 시간은 %eax 레지스터에 반환되고, 이 값은 `time` 변수에 저장됩니다("=a" (time) 부분). `movl (%1), %%eax` 라인은 ecx 레지스터가 가리키는 주소로부터 4 바이트를 읽어들입니다. 읽기 작업에 걸리는 시간을 측정하기 위해 **프로세서의 타임 스탬프 카운터** 를 활용합니다. **rdtsc** 커맨드는 64비트 타임 스탬프 카운터를 읽어서, 상위 32비트는 %edx, 하위 32비트는 %eax 레지스터에 반환합니다. 측정하려는 시간 간격이 짧기 때문에, 하위 32비트만 취급해도 됩니다. 위 코드에서는 먼저 측정한 기록을 `%esi` 레지스터에 옮겨둔 다음 작업 전의 카운터 값을 빼서 걸린 시간을 %eax에 남겨두고 있습니다.

이 기법의 핵심은 캐시에서 특정 메모리 라인을 축출하는 능력으로, **clflush** 명령어는 모든 코어의 L1, L2를 포함한 전체 캐시 계층에서 특정 메모리 라인을 제거합니다. 이 후 victim이 그 메모리 라인에 접근하면 **L3 cache** 에 로드되는 것을 보장할 수 있습니다. `mfence`와 `lfence` 명령어의 목적은 명령어 스트림을 **직렬화** 하여, 프로세서의 병렬 실행이나 최적화 등을 방지하고, 측정 결과를 최대한 정확하게 계산하는 것입니다. `lfence` 명령어는 자신보다 앞선 **로드(load)** 명령어들이 자신이 실행되기 전에 완료되도록 보장하고, 뒤따르는 어떤 명령어도 lfence보다 먼저 실행되지 않도록 하여 **부분적인 직렬화** 를 수행합니다. `mfence`의 경우, 모든 메모리 접근, fence, clflush 명령어들 간의 순서를 정렬하는데, 실행 순서 보장을 위해서는 이 둘을 적절히 조합하여야 합니다. 인텔에서는 명령어 직렬화를 위해서 **cpuid** 라는 강력한 명령어를 쓸 것을 권장하지만, 가상화 환경에서는 에뮬레이션 된 cpuid의 실행 시간이 너무 길어 사용하기 적절하지 않습니다. 코드의 마지막 부분에서는 측정 결과와 미리 정해둔 threshold를 비교하여 측정된 결과가 더 짧다면 캐시된 메모리를 로드했다는 의미가 됩니다. 

공격에 사용되는 threshold는 시스템마다 다르기에 측정을 해주어야 합니다. 본 연구에서는 위 코드를 활용하여 **메모리(RAM)에서 데이터를 가져오는 시간** 과 **L1 캐시에서 가져오는 시간** 을 각각 측정하였습니다. 후자를 측정할 때는 `clflush` 명령어를 제거했습니다. 아래 그림은 HP Elite 8300 (i5-3470 프로세서, CentOS 6.5 운영체제) 환경에서 각각 10만 번씩 측정한 결과를 나타냅니다. <br>

![f4](/assets/img/posts/papers/flush_reload_4.png) <br>

L1 캐시에서의 로드는 대부분 44 사이클로 측정되었는데, rdtsc와 펜스 명령어들의 오버헤드가 전부 포함된 값이긴 합니다. 메모리에서의 로드는 덜 일정하나 98% 이상이 270~290 사이클이었습니다. 한번씩 튀는 값들이 있었지만 200 사이클 밑으로는 하나도 없었습니다. 로드 작업의 소요 시간은 시스템 아키텍처와 소프트웨어 환경 모두에 따라 달라지는 것을 확인할 수 있었습니다. L1 측정값은 victim의 탐지 시간을 낮게 잡은 수치로, 실제 공격에서는 L1보다 조금 느린 L3에서 데이터를 확인하게 됩니다. 이러한 점을 고려하여, 본 연구에서는 threshold를 120 사이클로 설정하였습니다. 

FLUSH+RELOAD 기법을 사용하려면, spy와 victim 프로세스가 **캐시 계층 구조** 와 **메모리 페이지** 를 모두 공유하고 있어야 합니다(같은 물리적 메모리 공간). 비가상화 환경에서는, 공격자가 희생자 컴퓨터에서 코드를 실행할 수 있는 능력이 있어야 하나, 일반 권한만으로도 충분히 공격을 할 수 있습니다. 가상화 환경의 경우, 공격자는 victim VM과 동일한 호스트(물리 서버)에 위치한 VM에 접근할 수 있어야 합니다. **Content-aware sharing** 을 사용하는 시스템에서 메모리 페이지를 공유하려면, 공격 대상 실행 파일이나 공유 라이브러리에 대한 **읽기 권한** 이 필요합니다(같은 파일을 읽으면 OS가 알아서 병합). **De-duplication** 을 지원하는 시스템에서는, 공격자가 공격 대상 파일의 복사본에 접근할 수 있어야 합니다. OS나 하이퍼바이저가 복사본의 페이지들을 공격 대상 파일의 페이지들과 병합을 할 것입니다. 

## Attacking GnuPG
이 섹션에서는 FLUSH+RELOAD로 어떻게 GnuPG의 RSA 구현에서 private key를 추출하는지를 다룹니다. 

본 연구는 두 가지 하드웨어 플랫폼에서 공격을 테스트했습니다. 하나는 Intel Core i5-3470 프로세서와 8GB DDR3-1600 메모리를 탑재한 HP Elite 8300이고, 다른 하나는 두 개의 Xeon E5-2430 프로세서와 32GB DDR3-1333 메모리를 갖춘 Dell PowerEdge T420입니다. 각 하드웨어 플랫폼에서 두 시나리오, same-OS와 cross-VM 시나리오를 실험했습니다. 

동일 OS 테스트는 하드웨어 위에서 직접 구동되는 CentOS 6.5 리눅스를 사용하고, spy와 victim 프로세스는 시스템 내에서 두 개의 프로세스로 실행됩니다. 메모리 공유를 달성하기 위해, 스파이는 victim의 실행 파일을 스파이 자신의 가상 주소 공간으로 **mmap** 을 합니다. 리눅스 로더가 실행 파일을 실행할 때 자동으로 프로세스 메모리에 매핑하기 때문에, 수동 mmap을 하게 되면 spy와 victim은 그 파일의 메모리 이미지를 공유하게 됩니다. 프로세서가 2개인 Dell 머신에서는 **CPU affinity** 를 설정하여 같은 CPU 칩안에 두 프로세스가 위치하도록 설정하였습니다. 같은 프로세서 안에만 있다면 코어는 상관 없습니다. 

Cross-VM 시나리오의 경우 두 가지 다른 하이퍼바이저: HP 머신에서는 VMware ESXi 5.1, Dell 머신에서는 KVM 포함 CentOS 6.5 를 활용하였습니다. 각 하이퍼바이저 내에 victim, spy 두 VM을 생성합니다. 가상머신들은 CentOS6.5를 구동합니다. Spy는 victim의 실행 파일의 복사본을 `mmap`하여 메모리에 올립니다. 그렇게 되면 하이퍼바이저의 **page de-duplication** 을 통해 메모리 공유가 이뤄지게 됩니다. Dell 머신에서는 이전과 같이 `CPU affinity`를 설정하여 반드시 같은 물리 프로세서에서 실행되도록 보장하였습니다. 페이지가 공유되면, 공유하는 프로세스들의 가장 주소 공간에 있는 모든 페이지 엔트리들은 **동일한 물리 페이지** 를 가리키도록 매핑됩니다. LLC는 물리주소를 기준으로 태그가 붙기 때문에, 캐시 내의 엔트리는 **공유된 페이지의 물리주소에만 의존** 하며, 페이지가 매핑된 가상주소와는 아무런 상관이 없습니다. 

본 연구에서는 victim 프로그램의 실행 흐름을 추적하는 방식으로 접근합니다. 이를 위해 victim program의 코드 세그먼트 내의 메모리 위치에 대한 FLUSH+RELOAD 공격을 적용합니다. 코드 세그먼트 내의 주소들에 **probe** 를 심어두고, 감시 중인 메모리 라인에 있는 코드를 실행할 때마다 probe가 트리거되도록 하는 방식입니다.

이를 구현하기 위해, spy 프로그램은 시간을 `2500 사이클` 길이의 고정된 구간들로 나눕니다(2500 사이클에 한번씩 검사하겠다는 뜻). 각 슬롯마다 spy는 **Square, Multiply, Modulo Reduce** 연산 코드 중 각각 하나의 메모리 라인을 탐지(probe)합니다. Victim의 접근을 감지할 확률을 높이기 위해, 계산 중 빈번하게 실행되는 메모리 라인들을 선택했습니다(루프 안쪽 코드 같은 거). 또한 예측 실행의 영향을 줄이기 위해, 함수 도입부 근처의 메모리 라인들은 제외하였습니다. 메모리 라인들을 probe 한 후, spy는 해당 라인들을 캐시에서 flush 해버린 후, 현재 시간 슬롯이 끝날 때까지 대기합니다. 

![f5](/assets/img/posts/papers/flush_reload_5.png) <br>

2048 비트 키를 사용한 GnuPG 서명 과정 중 **100개의 시간 슬롯** 에 대한 측정 시간들이 위 그림에 표시되어 있습니다. 각 시간 슬롯에서, 공격자는 flush, probing을 반복합니다. Threshold보다 낮은 측정 값은 victim이 해당 메모리 라인에 접근했음을 의미합니다. 서명을 위한 **지수승(exponentiations)** 연산에는 총 15690 개의 슬롯이 소요되며, 시간적으로는 약 18밀리초 정도가 걸립니다. 지수 승 연산에 사용된 CRT-RSA component의 길이는 각각 1022, 1023 비트 길이입니다. <br>

![f6](/assets/img/posts/papers/flush_reload_6.png) <br>

위 그림은 100개의 시간 슬롯에 대한 측정 그래프를 확대한 모습으로, threshold 아래의 캐시된 probe만 보여주고 있다. 그림을 보면 지수 승 연산의 단계들이 명확하게 보이는데, Square-Reduce-Multiply-Reduce의 시퀀스는 victim이 `set bit`를 처리하고 있었음을 확실하게 보여줍니다. 또한 그림에서는 예측 실행이 발생한 모습도 나타나는데, 프로세서는 bit의 값이 다 계산될 때까지 기다리는 것보다는 bit가 clear일거라 생각하고 캐시에 square 계산을 위한 라인을 미리 가져왔다는 것을 보여주고 있습니다. 이렇게 공격자는 연산들의 순서, 패턴을 인식함으로써 암호화에 쓰인 지수의 비트들을 복원해낼 수 있습니다.

하지만 시스템 활동(다른 프로세스, 인터럽트 등)으로 인해 spy가 시간 슬롯을 놓치는 경우가 발생할 수 있습니다. Spy는 사이클 카운터가 급증하는 것을 확인하면, 이때 시간 슬롯을 놓쳤음을 인식합니다. 100개의 시간 슬롯을 측정한 그래프에서도 3983, 3984번 시간 슬롯에서 spy가 슬롯을 놓쳤다는 것을 확인할 수 있습니다. 놓친 슬롯이 적으면 앞뒤 문맥을 보고 유추해낼 수 있지만, 이 수가 늘어나면 복구하기 힘들어지면서 `capture error`로 이어질 것입니다.

캡처 오류의 빈도를 측정하기 위해, spy 프로그램을 사용하여 1000회의 서명 과정을 관찰, 캡처하였습니다. Spy 프로그램은 서명이 실행되는 동안 실행 중이도록만 보장해두었고, spy와 GnuPG의 실행을 동기화하거나 spy를 껐다 켜는 행위 등은 없었습니다. <br>

![f7](/assets/img/posts/papers/flush_reload_7.png) <br>

실험 결과는 위 테이블과 그림에 요약되어 있으며, spy의 로그를 스크립트로 분석한 결과입니다. HP-CentOS 환경에서 3번 중 1번꼴로 단 하나의 비트 오류 없이 키를 추출하였고, 나머지 환경에서도 오류가 크지 않았습니다. 그리고 각 머신에서, same-OS 시나리오의 결과가 cross-VM 시나리오보다 좋았는데, 이는 **가상화 계층의 추가적인 오버헤드** 때문인 것으로 추측이 됩니다. 사람이 수동으로 개입하여 검사 결과가 좋아진다고 해도, 오류의 개수가 여전히 브루트 포싱을 하기에는 많을 수도 있습니다. 이때 쓸 수 있는 전략은 $d_p$, $d_q$ 중 오류가 더 적은 쪽의 CRT 구성 요소를 공략하여 탐색 공간을 줄이는 방법입니다. 지수 비트들의 **부분적인 정보** 만으로 RSA 비밀키를 복구해내는 알고리즘들도 여럿 제안되었으나, 본 논문의 공격은 비트들의 양은 충분하나 정확한 위치를 복구하는 것이 아니라 기존 알고리즘들을 사용하는 데는 한계가 있습니다. 

키를 복구하는 다른 방법으로는, 여러 차례의 서명 연산으로부터 키를 추출해낸 것이 있습니다. Victim이 **동일한 비밀키로** 여러번 서명 연산을 수행할 때, 공격자가 이를 캡처하고 나서 결과들을 비교, 결합한다면 모든 실험에서 오류가 발생하는 것이 아니라면, 거의 100 퍼센트 가까운 확률로 항상 키를 복원해낼 수 있습니다. 

본 연구에서 제시하는 공격은 굉장히 강력하지만, 몇가지 한계점을 가지고 있습니다.
1. 공격이 성공하려면, spy와 victim은 반드시 같은 프로세서 위에서 실행되어야 합니다. 본 연구에서는 **processor affinity** 를 설정하여 해결하였지만, 실제 환경에서는 시스템 스케줄러에 의존하게 되어, 공격 성공을 보장할 수 없습니다.
2. 연구를 진행할 때는 시스템의 유일한 부하가 spy와 victim이었지만, 실제 환경에서는 여러 프로세스가 동시에 실행되면서 데이터 캡처에 영향을 줄 것입니다. 또한 여러 GnuPG 인스턴스가 병렬로 실행될 때 spy는 인스턴스들을 구별하지 못해 어떠한 데이터도 복구할 수 없습니다. 
3. 실험을 진행한 Dell 머신에서는 세 곳을 probing 하는데 `2200 사이클`이 소요되었는데, 키 길이가 짧아 측정 속도보다 암호화 속도가 더 빠른 상황에서는 중간 과정을 세밀하게 관측하지 못할 것입니다. 즉, 키가 짧아질 수록 비밀키를 복구하는게 어려워집니다. 

## Mitigation Techniques
FLUSH+RELOAD 공격은 작동을 위해 다음 네 가지 조건에 의존합니다. 이 중 **하나라도** 방지하면 공격을 차단할 수 있게 됩니다.
1. 민감한 데이터가 메모리 접근 패턴으로 드러나는 데이터 흐름
2. Spy와 victim 간의 메모리 공유
3. 정확하고 고해상도의 시간 측정
4. `clflush` 명령의 제한 없는(unfettered) 사용

`clflush` 명령어 사용에 대한 권한 확인이 없다는 점은 x86 아키텍처의 약점입니다. 이 명령어의 주된 용도로는 **메모리 일관성(Memory Coherence)** 강제, 캐시 사용 제어(성능 최적화) 등이 있습니다. 첫 번째 기능은 분명히 시스템 기능이고, 두 번째 용도는 다른 프로세스가 해당 데이터에 접근하지 않는다는 가정에 기반하므로, 본 논문에서는 `clflush` 사용을 다음과 같이 제한할 것을 얘기하고 있습니다. **Page Attribute Table** 에 플러시 접근을 제한하는 메모리 속성을 추가함으로써 구현할 수 있습니다.
1. 프로세스가 **쓰기 권한** 을 가진 페이지
2. 시스템이 명시적으로 `clflush`를 허용한 메모리 페이지 

Arm 아키텍처에도 캐시 라인을 축출하는 명령어가 존재하지만, 권한이 상승된 상태에서만 사용할 수 있어 FLUSH+RELOAD 공격을 사용할 수 없습니다. 또한 최신 AMD 프로세서에서도 공격이 작동하지 않는 것을 확인했는데, probing하는 어셈블리 코드가 `clflush` 유무에 관계없이 동일한 결과를 반환합니다. `rdtsc` 명령어를 유사한 `rdtscp` 명령어로 교체하면 측정 문제가 해결되지만 두 가지 문제가 존재합니다. 첫 번째는 데이터가 축출된 후에도 캐시에 잠시 머물러 있는 것으로 보이고, 두 번째 문제는 victim이 접근을 해도 spy가 이를 캡처해내지 못합니다. 이에 대한 가능한 시나리오는 AMD 캐시가 **non-inclusive** 구조라는 것입니다. 즉, L1의 데이터가 반드시 L2, L3에 있어야 할 필요가 없습니다. 캐시 구조가 다른 구형 Opteron 2212와 같은 프로세서에서는 본 공격이 작동하였습니다. 

앞서 언급한 하드웨어 기반 대응책들은 즉각적인 해결책이 되기 힘듭니다(새로 개발해야 하고 시간도 오래 걸림, 구형 모델은 계속 취약). 즉, 공격을 즉각적으로 완화하려면 소프트웨어 기반의 해결책이 필요합니다. 또 다른 해결책은 spy와 victim 사이의 **메모리 공유를 막는 것** 으로, 프로세스 간의 페이지 공유를 방지하면 FLUSH+RELOAD 공격을 방지할 수 있습니다. 그러나 이러한 접근은 현대 운영체제의 메모리 효율성을 높여가는 흐름과는 역행하는 방식이라 feasible 한 방법이 아니고, 그 대신 **프로그램 로더** 를 변경하여 민감한 코드의 공유를 피하는 것이 가능할 수 있습니다. 또 다른 부분적인 해결책은 **page de-duplication** 을 비활성화하여 가상화된 시스템에서 VM간의 공격을 방지하는 것입니다. 

**소프트웨어 다양화(Software diversification)** 는 프로세서의 주소 공간 내에서 객체(코드, 데이터 등)의 위치를 섞어버리는 기술들의 집합으로, 대부분은 메모리 오염 공격에 대응하기 위해 개발되었지만, 일부는 메모리 공유 방지를 통해 FLUSH+RELOAD mitigation으로 이어질 수도 있습니다. 구체적으로, 가상화 환경에서 코드와 데이터의 **정적 재배치(static reordering)** 을 사용하면, VM마다 고유한 복사본이 생성되어 de-duplication 대상이 되지 않습니다. 실행 시간에 프로그램을 다양화 하는 것도 마찬가지로 방법이 될 수 있습니다. 전술하였듯이 가상 주소의 매핑만 섞는건 이 공격에 아무런 영향을 주지 못합니다. 

FLUSH+RELOAD는 다른 부채널 공격과 마찬가지로, 고해상도 시간 측정에 의존합니다. 해상도를 낮추거나 측정에 노이즈를 추가하는 것으로 공격에 대응할 수 있습니다. 물론 이 경우에도 공격자가 다른 방법(네트워크 패킷 데이터, 시계 프로세스 독립적으로 실행 등)을 통해 고해상도 시간 측정을 할 수도 있습니다. <br>

![f8](/assets/img/posts/papers/flush_reload_8.png) <br>

위에서 논의한 해결책들과 관계없이, 암호화 알고리즘은 반드시 이 공격으로부터 보호되어야 합니다. 취약점 공개 이후 GnuPG팀은 GnuPG 1.4.14와 libgcrypt 1.5.3 버전을 배포하였습니다. 위 코드에서 볼 수 있듯이 **Square-and-Multiply-Always** 알고리즘을 사용하여 공격을 완화합니다. 위 코드는 각 비트에 대해 square, multiply를 모두 실행하되, 비트 값이 0이면 곱셉 결과를 무시합니다.

보안 패치를 위해 효과가 없는 명령어를 도입할 때는 항상 **컴파일러의 최적화** 를 신경써야 합니다. GnuPG 패치의 경우, optimizer는 추가된 덧셈 연산이 부작용을 가지지 않는다는 사실을 알 수 없습니다. 그렇기에 보수적인 접근을 취하여 해당 함수를 삭제하지 않고 호출합니다. 이 구현에는 여전히 비트 값에 따라 실행 여부가 달라지는 작은 코드 영역이 포함되어 있어 이론적으로는 부채널 공격의 대상이 될 수 있지만, 추측 실행 때문에 프로세서는 비트 값과 관계없이 해당 영역에 접근할 가능성이 높고, 영역의 길이가 캐시 라인 하나보다 짧아 **뒤에 오는 코드와 동일한 캐시 라인** 에 포함될 가능성이 높습니다. 따라서 본 연구에서는 이 패치가 공격을 방어한다고 간주하고 있습니다. 

그러나 이 수정안은 **분기 예측 분석(Branch Prediction Analysis)** 에 취약할 가능성이 높습니다. 또한 데이터에 대한 접근 패턴이 지수 비트 값에 의존하기에, 이 코드는 **PRIME+PROBE** 공격에 취약할 가능성이 있습니다. 이러한 공격들은 **상수 시간 지수승** 을 사용하여 예방할 수 있는데, 이는 실행되는 명령어 순서와 접근하는 메모리 위치가 고정되어 있어 지수 비트 값에 의존하지 않는 방식입니다. OpenSSL의 RSA 지수승 구현에서 메모리 라인에 대한 접근 패턴은 비밀 지수 비트에 의존하지 않습니다. 즉, 전체 실행 시간이 완전히 같지는 않아도 FLUSH+RELOAD에는 취약하지 않다는 뜻입니다. 그런 상수 시간 지수승도 일반 소프트웨어가 사용하기에는 너무 무겁다는 점에서 만병통치약은 아닙니다.