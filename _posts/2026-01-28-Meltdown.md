---
title: "Meltdown: Reading Kernel Memory from User Space"
date: 2026-01-28 00:00:00 +0900
categories: [Papers]
tags: [security, side channel]
permalink: /posts/Meltdown/
math: true
---

# Summary for Meltdown: Reading Kernel Memory from User Space

## Introduction
현대 운영체제에서 **메모리 격리(memory isolation)** 는 시스템 보안에 있어 중심적인 역할을 하고 있습니다. 메모리 격리를 통해 멀티프로그래밍이나 클라우드 환경 등을 안전하게 구축할 수 있습니다. 커널과 사용자 프로세스 간의 격리는 **프로세서의 권한 비트(supervisor bit)** 를 통해 접근 여부를 정하는 방식으로 이뤄지는데, 이 비트는 커널 코드를 실행할 때만 1이 되고 사용자 프로세스로 돌아갈 때는 0으로 변합니다. 이러한 하드웨어 특징 덕분에 각 프로세스의 주소 공간에 커널을 매핑하여 인터럽트 핸들링 같은 `유저-커널 전환`을 아주 빠르고 효율적으로 구현할 수 있게 됩니다.

본 연구에서 제안하는 **멜트다운(Meltdown)** 공격은 메모리 격리를 무시하고 사용자 프로세스에서 전체 커널 메모리를 읽을 수 있는 공격입니다. 본 공격은 대부분의 현대 프로세서에 존재하는 **비순차 실행(out-of-order execution)** 에서 비롯하는 side effect를 활용하여 진행됩니다. 

비순차 실행은 최신 프로세서들이 execution unit들을 최대한 활용하여 효율을 높이기 위해 활용하는 기법으로 memory fetch 같은 instruction 때문에 실행을 `stall` 해야 할 때, 기다리기만 하는게 아니라 뒤에 있는 instruction들을 살펴보고 이들을 쉬고있는 execution unit들에게 스케줄링합니다. 그러나 이러한 비순차 실행은 시간차이에서 정보가 유출될 수 있는 등 여러 side-effect를 갖고 있기도 합니다.

보안 측면에서 한가지 심각한 문제를 발견할 수 있었는데, 취약한 out-of-order CPU에서 권한이 없는 프로세스가 **권한이 필요한 영역의 메모리를 읽어 임시로 CPU 레지스터에 저장** 하고, 나아가 그 값을 갖고 배열 인덱스 등을 계산까지 할 수 있다는 사실을 발견하였습니다. Instruction이 사실은 실행되면 안된다는 걸 알고난 후 결과를 무시해버리면 `architectural level`에서는 이론적으로 안전하지만, 비순차 실행은 캐시에도 영향을 주기 때문에 **microarchitectural level**에서는 그렇지 않습니다. 캐시에 기록이 된다는 것은 캐시 부채널 기법을 통해 **covert channel** 을 만들어 microarchitecture 뒤에 숨겨진(elusive) 상태로부터 원하는 데이터를 추출해낼 수 있다는 것을 의미합니다. 즉, 공격자는 전체 커널 메모리를 덤프한 다음 FLUSH+RELOAD와 같은 부채널 기법을 활용하여 커널 메모리를 얻어낼 수 있습니다. 

본 논문에서는 다양한 최신 데스크탑, 노트북, 클라우드 서버와 같은 환경에서 공격을 평가하였고, Linux, Android, OS X, Windows와 같은 운영체제들에서 환경에 따라 속도 차이는 있을 수 있으나 아주 많은 시스템에서 공격이 유효하다는 것을 확인하였습니다. 

KASLR에 대한 부채널 공격을 막기 위해 제안된 **KAISER** 기법은 Meltdown 공격에 대해서도 유효하다는 것을 확인하였으며, Windows, Linux, OS X에서도 이와 유사한 기법들을 도입하였습니다. Meltdown은 **Spectre** 공격과 차이가 있는데, 스펙터는 victim 프로세스의 코드를 분석하고 이에 맞는 공격 코드를 작성해야 하나(tailoring), 더 넓은 CPU에 적용되고 KAISER 기법에도 영향을 받지 않는다는 차이가 있습니다.

## Background
### Out-of-order Execution
비순차 실행은 CPU core에 있는 execution unit들을 최대한 쉬게 하지 않고 활용하며 utilization을 극대화하는 기법입니다. Instruction들을 순서대로 실행하는 대신, CPU는 필요한 데이터가 모이는대로 명령어들을 실행합니다. 실제로는, 비순차 실행을 지원하는 CPU들은 일종의 `예측 실행(speculatively)`을 제공하는데, CPU가 어떤 instruction이 필요할지 판단이 확실하게 되기 전에 그 instruction을 처리하는 것을 허용합니다. 본 논문에서는 용어를 더 엄밀하게 정의하여 **투기 실행(speculative execution)** 은 branch 뒤에 오는 instruction들을 실행하는 것, **비순차 실행(out-of-order execution)** 을 프로세서가 이전 instruction들을 **완료(commit, retire)** 하기 전에 instruction을 실행하는 것을 의미하는 것으로 합니다. 

1967년 Tomasulo는 instruction들을 동적으로 스케줄링하여 비순차 실행을 가능케하는 알고리즘을 소개하였습니다. 알고리즘에서는 **unified reservation station** 을 활용하여 CPU에서 데이터 값들이 레지스터에 저장되기를 기다리지 않고 계산되는 대로 사용될 수 있도록 하였고, 레지스터들의 이름을 고쳐 같은 물리 레지스터들을 사용하는 instruction들이 마지막으로 갱신된 값들을 사용하게 하여 RAW, WAR, WAW hazard를 해결하고자 했습니다. 나아가서 reservation unit은 **common data bus(CDB)** 로 모든 execution unit들을 연결하여, 피연산자(operand)를 필요로 하는 instruction들이 기다리고 있다가 CDB를 통해 값을 바로 받아와 연산을 진행할 수 있도록 하였습니다. <br> 

![m1](/assets/img/posts/papers/Meltdown_1.png) <br>

인텔 아키텍처에서 파이프라인은 `front-end`, `execution engine(back-end)`, `memory subsystem`으로 구성이 됩니다. x86 명령어들은 front-end에서 수집되어 **micro-operations($\mu$ OP)** 으로 디코딩된 후 execution engine으로 계속 전송이 됩니다. 위의 그림에서 볼 수 있듯이 비순차 실행은 execution engine에서 구현이 되는데, **Reorder Buffer** 는 레지스터 할당, 레지스터 이름 수정 및 명령어 확정을 담당합니다. $\mu$ OP들은 **Unified Reservation Station(Scheduler)** 로 이동하고, 스케줄러는 **Execution Unit** 들과 연결되어 있는 포트에 명령어들을 큐잉합니다. 각 execution unit들은 ALU, AES, AGU(주소 생성), load/store 등을 담당하는데, 메모리에 load, store 하거나 AGU를 담당하는 unit은 메모리 서브시스템에 연결이 되어 있습니다.

명령어 흐름은 순차적으로 실행되지 않는 경우가 많기 때문에 **branch prediction unit** 을 갖고 있으며, 이 유닛들은 조건문이 완전히 평가되기 전에 어디로 분기할지 예측을 하고자 합니다. 예측한 경로에 있는 명령어들은 별다른 의존성 이슈가 없다면 실행이 되어 결과가 계산이 되는데, 만약 예측이 맞았다면 그 결과가 바로 사용되고, 틀렸다면 reorder buffer는 버퍼를 비우고 스케줄러를 다시 초기화하여 정상 상태로 롤백합니다. 분기 예측에도 여러 방법이 연구되었는데, 명령어만 보고 정적으로 하거나, 런타임 정보를 수집하여 동적으로 예측하는 방법들이 있고, 현대 프로세서들은 **two-level adaptive predictor** 를 활용하여 마지막 n회의 분기 결과를 기록한 후, 이를 활용하여 예측을 하는 방법을 종종 사용합니다. 

### Adress Spaces
프로세스 간 격리를 제공하기 위해 OS는 가상 주소들이 물리 주소로 변환되는 가상 주소 공간을 사용합니다. 가상 주소 공간은 페이지라는 고정된 크기의 단위 공간으로 나뉘며, 페이지들은 **translation table(페이지 테이블, 멀티 레벨 가능)** 을 통해 VA -> PA 매핑이 계산됩니다. Translation table에서는 매핑 외에도 권한 체크, rwx, 유저 접근 여부 확인과 같은 보안 속성도 저장이 됩니다. 현재 프로세스가 사용하는 translation table(page table)의 주소는 특수한 CPU 레지스터에 저장이 되는데, 인텔의 경우는 **CR3** 레지스터에 저장이 됩니다. 컨텍스트 스위칭이 일어날 때 시스템에서 이 레지스터도 프로세스에 맞게 업데이트를 하기 때문에, 각 프로세스는 자신의 주소 공간만 접근할 수 있습니다. <br>

![m2](/assets/img/posts/papers/Meltdown_2.png) <br>

각 주소 공간은 유저 영역과 커널 영역으로 나뉘는데, 커널 공간은 프로세서가 privileged mode로 작동하고 있을 때에만 접근할 수 있습니다. 커널은 자기 자신만을 위한 메모리 뿐만 아니라 유저 프로세스의 메모리에도 접근을 해야 하기 때문에(예: read 같은 시스템콜), 보통 전체 물리 메모리가 커널에 매핑이 됩니다. Linux와 OS X에서는 **direct-physical map** 을 활용하여 전체 물리 메모리를 사전에 정의된 가상 공간에 매핑합니다. Windows에서는 direct-physical map 대신 `paged pools, non-paged pools, system cache`를 활용하여 각 프로세스의 커널 주소 공간에 큰 크기의 물리 메모리를 매핑합니다.

## A Toy Example
![m3](/assets/img/posts/papers/Meltdown_3.png) <br>

위의 코드는 exception을 일으킨 다음 배열에 접근을 하는 코드입니다. Exception은 발생하면 그 원인과 관계없이 무조건 커널의 exception handler로 실행 흐름이 넘어갑니다. 따라서 원래대로라면 위의 코드는 배열을 절대로 접근할 수 없지만 비순차 실행을 사용하는 CPU에서는 line 1과 line 3가 아무 의존성 관계가 없기 때문에 배열을 접근하는 코드를 실행할 수 있습니다. 그러나 exception이 발생하기 때문에 비순차적으로 실행된 코드들은 완료(retire)되지는 않고 결과가 무시됩니다. 그러나 결과는 무시되어도 데이터를 가져오는 과정에서 이 값들이 캐시에 올라가기 때문에 **microarchitectural side-channel** 공격을 활용하여, 무시되어 결과가 반영되지는 않았지만 캐시에는 남아있는 흔적을 찾을 수 있습니다. 본 연구에서는 Flush+Reload 기법을 사용하여 특정 라인이 캐시되었는지 여부를 판단하였습니다. <br>

![m4](/assets/img/posts/papers/Meltdown_4.png) <br>

예시 코드에서는 `data` 변수의 값에 따라 비순차 메모리 접근이 발생할 대 다른 캐시 라인이 접근됩니다. data를 4096, 4kb로 곱하였기 때문에 `probe_array`에 대한 접근은 4kb 거리를 두고 떨어져있으며, 이 때문에 서로 다른 인덱스에 대한 접근은 항상 **다른 페이지에 대한 접근** 이 됩니다. 또한 데이터를 가져올 때 인접한 데이터도 불러오는 prefetch도 페이지 범위 안에서 작동하기 때문에 캐시된 라인을 통해 `data` 값을 알아낼 수 있습니다. 위 그림에서는 비순차 실행을 수행한 다음 페이지들을 돌며 접근 시간을 측정한 결과입니다. Page 84번에만 cache hit이 발생한 것을 알 수 있는데, 이를 통해 절대 실행될 수가 없는 코드만으로도 microarchitectural state가 변할 수 있다는 사실을 알 수 있습니다.

## Building Blocks of the Attack
이전 섹션에서 다뤘듯이 모든 프로세스의 주소 공간에는 커널의 전체 공간 뿐만 아니라, 유저 공간 전체 메모리, 심지어는 레지스터의 값까지 저장이 됩니다(context switch 할 때 TCB에 저장됨). 물론 이 영역들에 접근하려면 당연히 privileged mode여야 합니다. <br>

![m5](/assets/img/posts/papers/Meltdown_5.png) <br>

본 연구에서는 이러한 `privileged-mode isolation`을 우회하여 공격자가 메모리에 올라가 있는 커널 메모리, 다른 프로세스의 메모리 등을 전부 읽어낼 수 있다는 걸 보여주고자 합니다. 위 그림에서 보여지듯이 Meltdown 공격은 크게 두가지로 구성이 됩니다. 

첫 번째는 CPU가 원래라면 절대 실행될 수 없는 instruction들을 실행하도록 만드는 것입니다. 논문에서는 이전 예시에서 보았단 배열 접근과 같이 비순차적으로 실행되면서 side-effect를 남기는 instruction들을 **일시적 명령어(transient instruction)** 라고 부르기로 하였다. 나아가서 이러한 명령어들의 묶음은 **transient instruction sequence** 라고 부릅니다. 일시적 명령어를 공격에 활용하려면 일시적 명령어들이 반드시 추출하고자 하는 비밀값을 활용해야 합니다. 

두 번째는 이러한 일시적 명령어들이 남긴 흔적들을 architectural state로 가져와 추출한 비밀값을 활용하는 것입니다. 논문에서는 부채널 기법을 통해 만든 **covert channel** 로 이를 구현하고 있습니다. 

### Executing Transient Instructions
커널 페이지와 같이 유저가 접근해서는 안되는 페이지에 접근을 시도하면 exception이 발생하면서 애플리케이션을 종료시키는데, 공격자는 user-inaccessible 영역에 접근하려면 예외를 어떻게 다룰지 정해두어야 합니다. 본 논문에서는 일시적 명령어를 실행한 후 exception이 발생했을 때, 이를 catch하는 **exception handling** 과 일시적 명령어를 실행한 후 흐름을 옮겨 exception이 발생하지 않도록 하는 **exception suppression** 두 가지 접근을 제안하고 있습니다.

#### Exception Handling
제일 단순한 방법은 커널 페이지와 같은 영역에 접근하기 전에 공격 애플리케이션을 `fork` 하여 자식 프로세스가 메모리 접근을 하게 만드는 것입니다. 부모 프로세스는 자식이 접근하고 종료된 다음 부채널 기법을 활용하여 값을 알아낼 수 있습니다. 또 다른 방법은 segmentation fualt 같은 exception을 직접 다루는 **signal handler** 를 설치하여 프로세스를 새로 만들 필요가 없도록 하여 오버헤드를 줄이는 방법입니다.

#### Exception Suppression
**Transactional memory** 는 메모리 접근들을 하나의 원자적 연산으로 묶어 에러가 발생하면 이전 상태로 롤백될 수 있도록 하는 기능을 제공합니다. Transaction 안에서 exception이 발생하면 프로그램이 종료되지 않고 architectural state만 초기화가 됩니다. 또한 절대로 참으로 평가될 수 없는 조건문 뒤에 일시적 명령어들을 배치하여 비정상적인 메모리 접근은 투기 실행을 통해서만 발생하도록 만들 수 있습니다. 이 방법은 `branch predictor`를 사전에 정교하게 학습시켜두어야 합니다.

### Building a Covert Channel
부채널 기법이 하나의 covert channel을 만들어낸다고 생각하면 일시적 명령어들을 채널의 송신부, 캐시 상태의 변화를 관측하여 비밀값을 알아내는 부분을 일종의 수신부라고 생각할 수 있습니다. 본 연구에서는 빠른 속도와 높은 해상도, 낮은 노이즈 등을 이유로 Flush+Reload 기법을 활용합니다. 일시적 명령어들이 메모리에 접근을 하면 그 주소는 캐시에 로드가 되고, 수신부는 시간을 측정하여 어떤 주소가 캐시에 올라갔는지 아닌지를 알아낼 수 있습니다. 즉, 송신부에서는 관측되고 있는 캐시 위의 주소에 접근함으로써 `1비트`를, 접근하지 않음으로써 `0비트`를 송신할 수 있습니다. 이걸 여러개의 캐시 라인으로 확장하면 이전의 toy example처럼 full byte를 한번에 복구해낼 수 있습니다. 그러나 Flush+Reload는 일시적 명령어 실행에 비해 시간이 훨씬 많이 걸리기 때문에 1비트씩 송신하는 것이 훨씬 효율적입니다. 

## Meltdown
#### Attack Setting
Meltdown 공격 시나리오에서 공격자는 타겟 시스템에서 un-privileged 코드 실행 권한을 갖고 있습니다. 머신에 대한 물리적 접근은 필요로 하지 않는다. 나아가서 타겟 시스템은 ASLR, KASLR, SMAP, SMEP 등의 **state-of-art** 소프트웨어 기반 방어 기법들이 전부 적용되어 있고 OS에도 취약점이 없다고 가정합니다. 공격자는 `secret user data`를 노리고 있는 상황입니다. 

### Attack Description
멜트다운은 3 단계에 걸쳐 진행됩니다.
1. 공격자는 원래 접근할 수 없어야 하는 공격자가 선택한 주소의 값이 레지스터에 로드가 됩니다
2. 일시적 명령어들은 레지스터에 로드된 값에 따라 캐시 라인에 접근합니다
3. 공격자는 Flush+Reload 기법을 통하여 접근된 캐시 라인을 식별하고 비밀값을 추출합니다 

위의 과정을 반복한다면 커널 전체의 메모리를 덤프할 수 있습니다. <br>

![m6](/assets/img/posts/papers/Meltdown_6.png) <br>

위의 코드는 일시적 명령어와 송신부의 기본적인 구현을 보여주고 있습니다. C 코드로도 같은 기능을 하도록 구현할 수 있습니다.

#### Step 1: Reading the secret
메인 메모리에서 레지스터로 값을 가져오려면 메인 메모리에 있는 값을 **가상 주소로 참조** 할 수 있어야 합니다. CPU는 가상 주소를 물리 주소로 변환하는 동시에, 가상 주소의 권한 비트를 확인하여 이 주소를 유저가 접근할 수 있는지를 확인합니다. 이전에 다뤘듯이 프로세스의 가상 공간에 커널이 통째로 매핑되어 있기 때문에, 가상 주소는 항상 유효한 물리 주소를 반환하고, CPU가 그 주소에 접근을 할 수 있습니다. 즉, Meltdown 공격은 비순차 실행을 악용하여 커널 주소의 값을 불러오는 순간과 CPU가 권한 에러를 발생시키는 사이의 **time window** 를 활용하여 값을 알아냅니다. 

Line 4에서 rcx에 저장된 커널 주소로부터 1바이트를 읽어 rax 레지스터의 LSB에 로드합니다. 더 자세하게는 `MOV` instruction이 수집된 후 $\mu$ OP로 디코딩 된 다음 reorder buffer로 전송됩니다. 코드의 rax, rcx 같은 아키텍처 레지스터는 비순차 실행을 가능하게 하기 위해 물리 레지스터로 매핑이 됩니다. CPU의 파이프라이닝으로 인해 이미 후속 명령어들도 $\mu$ OP로 디코딩 되어 reservation station에 할당이 되어 있을 것입니다. $\mu$ OP들은 스케줄러에서 기다리면서, 커널 주소에서 읽은 데이터가 CDB에 오는대로 실행을 재개할 것입니다. 나아가서 프로세서 인터커넥트와 캐시 일관성 프로토콜은 멀티코어 환경에서도 해당 메모리 주소의 가장 최신 값이 읽히도록 보장합니다.

$\mu$ OP는 비순차적으로 실행되지만, 결과는 순차적으로 retire하면서 architectural state에 결과가 반영이 됩니다.만약 커널 주소 접근 등 예외가 발생하면 파이프라인이 flush 되고 아키텍처 상태는 롤백되지만, **데이터 로드와 예외처리 시점 사이의 레이스** 로 인해 캐시에 남은 마이크로아키텍처 흔적은 악용될 수 있습니다.

#### Step 2: Transmitting the secret
Step 1의 transient instruction sequence는 MOV 명령어가 retire되어 예외를 발생시키기 전에 실행되어야 합니다. 이 시간 내에 비밀값을 기반으로 계산을 수행하면, 그 결과를 covert channel을 통해 전송할 수 있습니다. 캐시 기반 covert channel을 구성하기 위해서 송신부에서는 비밀값을 기반으로 계산된 주소에 접근하여 해당 캐시 라인을 로드합니다. 수신부에서는 probe array 전체가 미리 flush되어 있어야 하며, line 5에서 페이지 크기(4KB)를 곱하는 것처럼 배열 원소 간 충분한 간격을 두어 하드웨어 prefetcher의 간섭을 방지해주어야 합니다. 결과적으로, 비밀값에 해당하는 캐시 라인만 캐시에 남게 됩니다.

Meltdown 공격은 본질적으로 race condition이기 때문에, 비순차 실행 과정에서 실제 비밀값 대신 **0이 읽히는 경향(noise-bias)**이 있습니다. 이를 보완하기 위해 line 6에서 retry 로직을 도입하여, `0`이 읽히면 비밀값 읽기를 재시도합니다. Line 7에서는 페이지 크기가 곱해진 비밀값을 probe array의 베이스 주소에 더하여 해당 주소에 접근합니다. 이 접근으로 해당 캐시 라인이 요청 코어의 L1 데이터 캐시에 로드되고, 캐시의 inclusive 특성으로 인해 L3 캐시에도 함께 로드됩니다. 이후 다른 코어에서도 이 캐시 상태를 관측할 수 있습니다.Transient instruction sequence는 예외 발생과 경쟁하므로, Step 2의 실행 시간을 줄이면 공격 성공률이 향상됩니다. 예를 들어, probe array에 대한 주소 변환 결과를 미리 TLB에 로드해두면 주소 변환 지연을 제거할 수 있습니다.

#### Step 3: Receiving the secret
일시적 명령어가 실행되면, 비밀값에 해당하는 단 하나의 캐시 라인만 캐시에 로드됩니다. 공격자는 Flush+Reload를 활용하여 이 마이크로아키텍처 상태를 architectural state로 변환합니다. 구체적으로, probe array의 256개 페이지를 순회하며 각 페이지의 첫 번째 캐시 라인에 대한 접근 시간을 측정합니다. 캐시 히트가 발생한 페이지 번호가 곧 비밀값입니다.

#### Dumping the entire physical memory
위 3단계를 주소를 바꿔가며 반복하면 커널 메모리 전체를 덤프할 수 있습니다. 주요 운영체제들은 전체 물리 메모리를 커널 주소 공간에 매핑하므로, 결과적으로 시스템의 모든 물리 메모리를 읽을 수 있습니다. 단, 커널 주소 접근 시 발생하는 예외가 프로그램을 종료시키므로, 앞서 다룬 exception handling 또는 suppression 기법을 함께 사용해야 합니다.

### Optimizations and Limitations
#### Inherent bias towawrds 0
Meltdown 공격은 본질적으로 race condition입니다. 비순차 실행 중 불법적인 메모리 로드가 발생할 때, CPU는 권한 검사 실패로 인해 값을 마스킹하거나, 데이터가 아직 도착하지 않아 추측값을 사용할 수 있습니다. 두 경우 모두 실제 비밀값 대신 `0`이 반환되는 경향이 있으며, 이를 **noise-bias** 라고 합니다. 최적화되지 않은 구현에서는 약 5%의 확률로 잘못된 `0`이 읽히며, 이는 공격의 신뢰성을 저하시키는 주요 원인입니다.

#### Optimizing the case of 0
`0`에 대한 noise-bias 때문에, probe array의 캐시 라인 `0`에서 캐시 히트가 발생해도 이것이 실제 비밀값인지 노이즈인지 구분할 수 없습니다. 따라서 캐시 라인 `0`의 측정을 생략하고, 다른 캐시 라인에서 히트가 없으면 비밀값이 `0`이라고 가정합니다. 또한 이전 코드의 line 6에서 구현된 것처럼, transient instruction sequence 내에서 `0`이 아닌 값이 읽힐 때까지 재시도하는 루프를 추가합니다. 이 루프는 예외 발생 시 자동으로 종료되므로 공격 속도에 영향을 주지 않습니다.

#### Single-bit transmission
기본 구현에서는 한 번에 8비트를 전송하고 256개의 캐시 라인을 측정합니다. 그러나 성능 병목은 Flush+Reload 측정 시간이므로, 1비트씩 전송하는 방식이 더 효율적일 수 있습니다. 비밀값을 시프트와 마스킹 연산으로 비트 단위로 분리한 뒤, 해당 비트가 `1`이면 캐시 라인 1에 접근하고 `0`이면 접근하지 않습니다. 수신부에서는 캐시 라인 1개만 측정하면 되므로 측정 시간이 크게 단축됩니다. 단, 1비트 전송 시 noise-bias로 인한 오류 확률이 약 50%에 가까워지는 단점이 있어, 전송 속도와 오류율 사이의 trade-off가 존재합니다. 어쨌든 두 경우 모두 에러율이 상당히 작기 때문에 evaluation은 싱클 비트 전송 메커니즘을 사용합니다.

#### Exception Suppressiong using Intel TSX
Intel TSX(Transactional Synchronization Extensions)를 활용하면 예외를 완전히 억제할 수 있습니다. TSX는 하드웨어 트랜잭셔널 메모리 구현으로, 트랜잭션 내에서 예외가 발생하면 아키텍처 상태를 롤백하고 예외 없이 프로그램 실행을 계속합니다. 그러나 마이크로아키텍처 상태인 캐시는 롤백되지 않아 부채널 공격이 여전히 유효합니다. 커널로 트랩하여 예외를 처리하는 것보다 훨씬 빠르기 때문에 covert channel의 대역폭이 증가하며, `0` 오류 확률도 0.008%까지 감소합니다.

#### Dealing with KASLR
KASLR(Kernel Address Space Layout Randomization)은 부팅 시 커널 코드와 direct-physical map의 위치를 무작위화합니다. 그러나 Linux KASLR의 엔트로피는 40비트에 불과하고, 매핑의 선형적 특성으로 인해 탐색 공간이 더 축소됩니다. 시스템에 8GB RAM이 있다고 가정하면, 8GB 간격으로 주소 공간을 탐색하여 최대 128번의 시도로 커널 위치를 찾을 수 있습니다. 따라서 KASLR은 Meltdown에 대해 수 초 내에 우회 가능한 미약한 방어책입니다.

## Evaluation
![m7](/assets/img/posts/papers/Meltdown_7.png) <br>
위 테이블은 Meltdown 공격이 성공적으로 진행된 세팅의 목록을 나타내고 있습니다. 평가를 위해서 Intel Core CPU를 사용하는 랩탑과 노트북, ARM 기반 스마트폰을 사용하였으며, 클라우드의 경우 Intel Xeon CPU에서 돌아가는 VM 위에서 테스트 하였습니다.

### Leakage and Environments
#### Linux
KAISER 패치가 적용되지 않은 Linux 커널의 다양한 버전에서 Meltdown 공격을 성공적으로 검증하였습니다. Linux 커널은 커널 주소 공간을 모든 사용자 프로세스의 주소 공간에 매핑하며, 권한 설정으로 접근을 차단합니다. Meltdown은 이 권한 설정을 우회하므로 전체 커널 메모리를 유출할 수 있습니다. 또한 Linux는 전체 물리 메모리를 커널 주소 공간에 직접 매핑(direct-physical map)하므로, 결과적으로 시스템의 모든 물리 메모리를 읽을 수 있습니다. 커널 4.12 이전에는 KASLR이 기본 비활성화 상태였으며, 이 경우 direct-physical map은 고정 주소에서 시작합니다. KASLR이 활성화된 경우에도 앞서 설명한 대로 수 초 내에 우회 가능합니다.

KAISER 패치는 사용자 공간에서 커널 메모리 매핑을 제거합니다. 인터럽트 핸들러와 같이 x86 아키텍처상 필수적인 일부 영역을 제외하고는 **커널 메모리에 대한 유효한 매핑** 이 존재하지 않습니다. 따라서 Meltdown으로 주소를 읽으려 해도 해당 주소를 해석할 수 없어 공격이 차단됩니다. 실험 결과, KAISER가 적용된 환경에서는 커널 및 물리 메모리 유출이 발생하지 않음을 확인하였습니다.

#### Windows
KAISER 패치 배포 직전의 Windows 10에서 Meltdown 공격을 성공적으로 검증하였습니다. Meltdown은 소프트웨어가 아닌 하드웨어 취약점이므로 운영체제와 무관하게 작동합니다.
Windows는 Linux의 direct-physical map과 달리 paged pool, non-paged pool, system cache 등 여러 메모리 풀을 통해 물리 메모리를 커널 주소 공간에 매핑합니다. 따라서 전체 물리 메모리를 선형적으로 덤프할 수는 없지만, 이 풀들에 매핑된 **대부분의 물리 메모리** 는 여전히 접근 가능합니다. 실험에서 Windows 커널 디버거를 사용하여 유출된 데이터가 실제 커널 메모리 내용과 일치함을 확인하였습니다.

#### Android
Samsung Galaxy S7(LineageOS Android 14.1, Linux 커널 3.18.14)에서 Meltdown을 검증하였습니다. 이 기기는 Samsung Exynos 8 Octa 8890 SoC를 탑재하고 있으며, ARM Cortex-A53 코어 4개와 Samsung 커스텀 Exynos M1(Mongoose) 코어 4개로 구성됩니다. 실험 결과, Cortex-A53에서는 공격이 성공하지 않았으나 Exynos M1 코어에서는 성공적으로 커널 메모리를 유출할 수 있었습니다. 이는 Meltdown 취약점이 특정 마이크로아키텍처 구현에 의존함을 보여줍니다.

#### Containers
Docker, LXC, OpenVZ 등 커널을 공유하는 컨테이너 환경에서 Meltdown 공격을 검증하였습니다. 컨테이너들은 동일한 커널을 공유하는 경우가 많기 때문에, 각 컨테이너에서 커널의 direct-physical map을 통해 전체 물리 메모리에 접근할 수 있습니다. Meltdown은 메모리 접근만 사용하며, Intel TSX를 활용하면 커널 트랩조차 발생시키지 않으며 공격이 가능합니다. 따라서 컨테이너 내부에서 공격을 차단할 방법이 없으며, 동일 호스트의 다른 컨테이너 메모리까지 유출될 수 있습니다. 이는 완전 가상화 대신 컨테이너를 사용하는 저가형 호스팅/클라우드 서비스에 특히 치명적입니다. 실험에서는 다른 사용자의 컨테이너 메모리를 성공적으로 유출하는 것까지 확인하였습니다.

#### Uncached and Uncacheable Memory
Meltdown이 L1 데이터 캐시에 존재하는 데이터만 유출 가능한지 검증하였습니다. 두 프로세스를 서로 다른 물리 코어에 고정시킨 후, 한쪽에서 데이터를 flush하고 다른 코어에서만 reload하는 실험을 수행하였습니다. 결과적으로 공격자 코어의 L1 캐시에 없는 데이터도 유출 가능함을 확인하였으며, 이는 Meltdown이 암묵적으로 데이터를 캐시에 로드하기 때문으로 추정됩니다. 또한 uncacheable로 설정된 페이지에 대해서도 실험하였습니다. 동일 코어에서 시스템 콜 등을 통해 해당 주소의 정상적인 로드를 유발하면, line fill buffer를 통해 데이터 유출이 가능함을 확인하였습니다. 단, memory-mapped I/O 영역은 아키텍처적 부작용이 있을 수 있어 공격이 작동하지 않습니다.

### Meltdown Performance
Meltdown의 성능을 평가하기 위해 커널 메모리에서 알려진 값을 유출하는 실험을 수행하였습니다. 이를 통해 읽기 속도뿐만 아니라 오류율도 함께 측정할 수 있습니다. 모든 테스트에서 covert channel로 Flush+Reload를 사용하고, exception suppression을 위해 Intel TSX를 활용하였습니다. 

Meltdown의 성능은 race condition에 크게 의존합니다. 대상 데이터가 코어에 가까울수록, 즉 L1 캐시에 존재할수록 race condition에서 승리할 확률이 높아집니다. 또한 속도와 정확도 사이의 trade-off 또한 존재한다는 사실을 발견하였습니다.

데이터가 캐시에 없는 uncached의 경우, race에서 승리하기 어려워서 속도가 굉장히 느렸으나, 다른 스레드에서 대상 메모리 주변을 prefetch하며서 동시에 대상 주소에 접근하여 공격 스레드가 적절한 타이밍에 데이터를 볼 확률을 높이거나, 대상 주소 주변에 대한 투기적 접근으로 하드웨어 prefetch를 유발하는 방법으로 개선할 수 있었습니다.

### Limitations on ARM and AMD
여러 ARM, AMD CPU에 대해서도 Meltdown 재현을 시도하였으나, Intel CPU나 Exynos M1 프로세서와 달리 재현에 실패하였습니다. 접근 불가능한 메모리 대신 시스템 레지스터를 대상으로 하는 변형된 Meltdown은 여러 ARM 프로세서에 적용 가능한 것으로 알려져 있습니다. AMD의 경우 아키텍처의 차이로 자사 CPU가 Meltdown에 영향받지 않는다고 공식적으로 발표하였습니다. 마이크로아키텍처의 세부 구현은 대부분 문서화 되지 않기 때문에 정확한 분석은 어려우나 핵심은 **권한이 없는 주소에 대한 로드와 후속 명령어가 마이크로아키텍처 수준에서 실행되고, fault는 해당 명령어가 retire될 때 처리된다** 는 점입니다. ARM, AMD, Intel에서의 로드 execution unit과 TLB의 설계가 다르며, 이 때문에 권한 검사 시점과 fault 처리 방식도 다를 것으로 추정됩니다. 

그러나 Section 3의 toy example은 ARM, AMD에서도 정상적으로 작동하였는데, 이는 비순차 실행 자체는 발생하며 불법적인 메모리 접근 이후의 명령어도 실행된다는 것을 의미합니다. 그러나 해당 CPU들이 권한 검사를 다른 방식으로 처리하기 때문에 커널 메모리까지는 유출이 되지 않는 것 같습니다. 

## Countermeasures
### Hardware
Meltdown 공격은 일종의 레이스 컨디션이기 때문에 비순차 실행을 쓰지 않거나, 메모리 로드를 할 때 권한 검사를 먼저 한 후 fetch를 하는 등의 방법을 생각해볼 수 있지만, 퍼포먼스 오버헤드가 무시무시할 것이다. 더 실용적인 방어기법으로는 **유저 영역과 커널 영역을 hard split** 하는 것을 제안할 수 있다. 이 기능은 CR4와 같은 CPU control register에 있는 **hard-split bit** 을 사용하여 최신 커널에서 선택적으로 활성화될 수 있다. 이 비트가 설정되면 커널은 주소 공간을 반으로 나눴을 때 윗 부분에만, 유저 공간은 아랫 부분에만 존재하게 되는데, 이렇게 나눠두면 memory fetch를 할 때 목적지만 보고 접근 권한 검사를 할 수 있다. 

### KAISER
Gruss et al. 이 제안한 **KAISER** 는 KASLR을 공격하는 부채널 공격들에 대한 방어 기법으로 제안되었으나, Meltdown에 대해서도 유효하다. 유저 공간에는 커널 공간으로의 유효한 매핑 주소가 없기 때문이다. 물론 몇몇 한계는 있다. x86 아키텍처 특성상 유저 공간에 privileged memory location을 조금은 남겨두어야 하기 때문에, 이 공간에 비밀값이 없더라도 포인터를 유출하여 KASLR을 우회할 수 있다. 

그럼에도 KAISER는 meltdown 공격에 대해 사용될 수 있는 최선의 방안으로 당장 시스템에 도입이 되어야 한다. 심지어 KAISER는 Meltdown 공격을 받아도 어떠한 커널 포인터도 유출되지 않도록 할 수 있다. 커널 포인터를 전부 트램폴린 함수로 바꾸고, 트램폴린 함수들을 커널에 매핑할 때 랜덤한 오프셋을 사용한다면 공격자는 Meltdown을 시도해도 커널 포인터 정보는 얻지 못하고, 트램폴린 포인터조차 KASLR 우회에 사용할 수 없다. 

Linux 커널의 KAISER 패치는 여러 최적화를 통해 개선된 후 메인라인에 합쳐지면서 **KPTI(kernel page-table isolation)** 으로 이름이 바뀌었다. 마이크로소프트 역시 KAISER와 유사한 **KVA Shadow** 라는 기법을 구현하였으며, Apple은 **Double Map** 이라는 기법을 구현하였다. 

## Discussion
Microarchitectural side channel을 통한 정보 유출은 오래전부터 알려졌으나, Meltdown은 하드웨어 최적화가 마이크로아키텍처 상태를 변경하여 보안을 위협한다는 점에서 의미가 있습니다. 현대 CPU는 마이크로아키텍처 상태에 영향을 미치는 최적화가 더 많이 존재할 것으로 예상되며, 신뢰할 수 없는 코드를 실행하는 하드웨어 기법은 재설계가 되어야 합니다.

KAISER는 주요 운영체제들에 통합이 되면서 Meltdown에 대한 방어 조치가 도입되었지만, 더 강력한 격리가 필요할 수 있으며 Spectre에 대한 방어책 역시 같이 고안이 되어야 시스템을 안전하게 보호할 수 있습니다. 