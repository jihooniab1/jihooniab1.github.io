---
title: "Meltdown: Reading Kernel Memory from User Space"
date: 2026-01-28 00:00:00 +0900
categories: [Papers]
tags: [security, side channel]
permalink: /posts/Meltdown/
math: true
---

# Summary for Meltdown: Reading Kernel Memory from User Space

## Introduction
현대 운영체제에서 **메모리 격리(memory isolation)** 는 시스템 보안에 있어 중심적인 역할을 하고 있습니다. 메모리 격리를 통해 멀티프로그래밍이나 클라우드 환경 등을 안전하게 구축할 수 있습니다. 커널과 사용자 프로세스 간의 격리는 **프로세서의 권한 비트(supervisor bit)** 를 통해 접근 여부를 정하는 방식으로 이뤄지는데, 이 비트는 커널 코드를 실행할 때만 1이 되고 사용자 프로세스로 돌아갈 때는 0으로 변합니다. 이러한 하드웨어 특징 덕분에 각 프로세스의 주소 공간에 커널을 매핑하여 인터럽트 핸들링 같은 `유저-커널 전환`을 아주 빠르고 효율적으로 구현할 수 있게 됩니다.

본 연구에서 제안하는 **멜트다운(Meltdown)** 공격은 메모리 격리를 무시하고 사용자 프로세스에서 전체 커널 메모리를 읽을 수 있는 공격입니다. 본 공격은 대부분의 현대 프로세서에 존재하는 **비순차 실행(out-of-order execution)** 에서 비롯하는 side effect를 활용하여 진행됩니다. 

비순차 실행은 최신 프로세서들이 execution unit들을 최대한 활용하여 효율을 높이기 위해 활용하는 기법으로 memory fetch 같은 instruction 때문에 실행을 `stall` 해야 할 때, 기다리기만 하는게 아니라 뒤에 있는 instruction들을 살펴보고 이들을 쉬고있는 execution unit들에게 스케줄링합니다. 그러나 이러한 비순차 실행은 시간차이에서 정보가 유출될 수 있는 등 여러 side-effect를 갖고 있기도 합니다.

보안 측면에서 한가지 심각한 문제를 발견할 수 있었는데, 취약한 out-of-order CPU에서 권한이 없는 프로세스가 **권한이 필요한 영역의 메모리를 읽어 임시로 CPU 레지스터에 저장** 하고, 나아가 그 값을 갖고 배열 인덱스 등을 계산까지 할 수 있다는 사실을 발견하였습니다. Instruction이 사실은 실행되면 안된다는 걸 알고난 후 결과를 무시해버리면 `architectural level`에서는 이론적으로 안전하지만, 비순차 실행은 캐시에도 영향을 주기 때문에 **microarchitectural level**에서는 그렇지 않습니다. 캐시에 기록이 된다는 것은 캐시 부채널 기법을 통해 **covert channel** 을 만들어 microarchitecture 뒤에 숨겨진(elusive) 상태로부터 원하는 데이터를 추출해낼 수 있다는 것을 의미합니다. 즉, 공격자는 전체 커널 메모리를 덤프한 다음 FLUSH+RELOAD와 같은 부채널 기법을 활용하여 커널 메모리를 얻어낼 수 있습니다. 

본 논문에서는 다양한 최신 데스크탑, 노트북, 클라우드 서버와 같은 환경에서 공격을 평가하였고, Linux, Android, OS X, Windows와 같은 운영체제들에서 환경에 따라 속도 차이는 있을 수 있으나 아주 많은 시스템에서 공격이 유효하다는 것을 확인하였습니다. 

KASLR에 대한 부채널 공격을 막기 위해 제안된 **KAISER** 기법은 Meltdown 공격에 대해서도 유효하다는 것을 확인하였으며, Windows, Linux, OS X에서도 이와 유사한 기법들을 도입하였습니다. Meltdown은 **Spectre** 공격과 차이가 있는데, 스펙터는 victim 프로세스의 코드를 분석하고 이에 맞는 공격 코드를 작성해야 하나(tailoring), 더 넓은 CPU에 적용되고 KAISER 기법에도 영향을 받지 않는다는 차이가 있습니다.

## Background
### Out-of-order Execution
비순차 실행은 CPU core에 있는 execution unit들을 최대한 쉬게 하지 않고 활용하며 utilization을 극대화하는 기법입니다. Instruction들을 순서대로 실행하는 대신, CPU는 필요한 데이터가 모이는대로 명령어들을 실행합니다. 실제로는, 비순차 실행을 지원하는 CPU들은 일종의 `예측 실행(speculatively)`을 제공하는데, CPU가 어떤 instruction이 필요할지 판단이 확실하게 되기 전에 그 instruction을 처리하는 것을 허용합니다. 본 논문에서는 용어를 더 엄밀하게 정의하여 **투기 실행(speculative execution)** 은 branch 뒤에 오는 instruction들을 실행하는 것, **비순차 실행(out-of-order execution)** 을 프로세서가 이전 instruction들을 **완료(commit, retire)** 하기 전에 instruction을 실행하는 것을 의미하는 것으로 합니다. 

1967년 Tomasulo는 instruction들을 동적으로 스케줄링하여 비순차 실행을 가능케하는 알고리즘을 소개하였습니다. 알고리즘에서는 **unified reservation station** 을 활용하여 CPU에서 데이터 값들이 레지스터에 저장되기를 기다리지 않고 계산되는 대로 사용될 수 있도록 하였고, 레지스터들의 이름을 고쳐 같은 물리 레지스터들을 사용하는 instruction들이 마지막으로 갱신된 값들을 사용하게 하여 RAW, WAR, WAW hazard를 해결하고자 했습니다. 나아가서 reservation unit은 **common data bus(CDB)** 로 모든 execution unit들을 연결하여, 피연산자(operand)를 필요로 하는 instruction들이 기다리고 있다가 CDB를 통해 값을 바로 받아와 연산을 진행할 수 있도록 하였습니다. <br> 

![m1](/assets/img/posts/papers/Meltdown_1.png) <br>

인텔 아키텍처에서 파이프라인은 `front-end`, `execution engine(back-end)`, `memory subsystem`으로 구성이 됩니다. x86 명령어들은 front-end에서 수집되어 **micro-operations($\mu$ OP)** 으로 디코딩된 후 execution engine으로 계속 전송이 됩니다. 위의 그림에서 볼 수 있듯이 비순차 실행은 execution engine에서 구현이 되는데, **Reorder Buffer** 는 레지스터 할당, 레지스터 이름 수정 및 명령어 확정을 담당합니다. $\mu$ OP들은 **Unified Reservation Station(Scheduler)** 로 이동하고, 스케줄러는 **Execution Unit** 들과 연결되어 있는 포트에 명령어들을 큐잉합니다. 각 execution unit들은 ALU, AES, AGU(주소 생성), load/store 등을 담당하는데, 메모리에 load, store 하거나 AGU를 담당하는 unit은 메모리 서브시스템에 연결이 되어 있습니다.

명령어 흐름은 순차적으로 실행되지 않는 경우가 많기 때문에 **branch prediction unit** 을 갖고 있으며, 이 유닛들은 조건문이 완전히 평가되기 전에 어디로 분기할지 예측을 하고자 합니다. 예측한 경로에 있는 명령어들은 별다른 의존성 이슈가 없다면 실행이 되어 결과가 계산이 되는데, 만약 예측이 맞았다면 그 결과가 바로 사용되고, 틀렸다면 reorder buffer는 버퍼를 비우고 스케줄러를 다시 초기화하여 정상 상태로 롤백합니다. 분기 예측에도 여러 방법이 연구되었는데, 명령어만 보고 정적으로 하거나, 런타임 정보를 수집하여 동적으로 예측하는 방법들이 있고, 현대 프로세서들은 **two-level adaptive predictor** 를 활용하여 마지막 n회의 분기 결과를 기록한 후, 이를 활용하여 예측을 하는 방법을 종종 사용합니다. 

### Adress Spaces
프로세스 간 격리를 제공하기 위해 OS는 가상 주소들이 물리 주소로 변환되는 가상 주소 공간을 사용합니다. 가상 주소 공간은 페이지라는 고정된 크기의 단위 공간으로 나뉘며, 페이지들은 **translation table(페이지 테이블, 멀티 레벨 가능)** 을 통해 VA -> PA 매핑이 계산됩니다. Translation table에서는 매핑 외에도 권한 체크, rwx, 유저 접근 여부 확인과 같은 보안 속성도 저장이 됩니다. 현재 프로세스가 사용하는 translation table(page table)의 주소는 특수한 CPU 레지스터에 저장이 되는데, 인텔의 경우는 **CR3** 레지스터에 저장이 됩니다. 컨텍스트 스위칭이 일어날 때 시스템에서 이 레지스터도 프로세스에 맞게 업데이트를 하기 때문에, 각 프로세스는 자신의 주소 공간만 접근할 수 있습니다. <br>

![m2](/assets/img/posts/papers/Meltdown_2.png) <br>

각 주소 공간은 유저 영역과 커널 영역으로 나뉘는데, 커널 공간은 프로세서가 privileged mode로 작동하고 있을 때에만 접근할 수 있습니다. 커널은 자기 자신만을 위한 메모리 뿐만 아니라 유저 프로세스의 메모리에도 접근을 해야 하기 때문에(예: read 같은 시스템콜), 보통 전체 물리 메모리가 커널에 매핑이 됩니다. Linux와 OS X에서는 **direct-physical map** 을 활용하여 전체 물리 메모리를 사전에 정의된 가상 공간에 매핑합니다. Windows에서는 direct-physical map 대신 `paged pools, non-paged pools, system cache`를 활용하여 각 프로세스의 커널 주소 공간에 큰 크기의 물리 메모리를 매핑합니다.

## A Toy Example
![m3](/assets/img/posts/papers/Meltdown_3.png) <br>

위의 코드는 exception을 일으킨 다음 배열에 접근을 하는 코드입니다. Exception은 발생하면 그 원인과 관계없이 무조건 커널의 exception handler로 실행 흐름이 넘어갑니다. 따라서 원래대로라면 위의 코드는 배열을 절대로 접근할 수 없지만 비순차 실행을 사용하는 CPU에서는 line 1과 line 3가 아무 의존성 관계가 없기 때문에 배열을 접근하는 코드를 실행할 수 있습니다. 그러나 exception이 발생하기 때문에 비순차적으로 실행된 코드들은 완료(retire)되지는 않고 결과가 무시됩니다. 그러나 결과는 무시되어도 데이터를 가져오는 과정에서 이 값들이 캐시에 올라가기 때문에 **microarchitectural side-channel** 공격을 활용하여, 무시되어 결과가 반영되지는 않았지만 캐시에는 남아있는 흔적을 찾을 수 있습니다. 본 연구에서는 Flush+Reload 기법을 사용하여 특정 라인이 캐시되었는지 여부를 판단하였습니다. <br>

![m4](/assets/img/posts/papers/Meltdown_4.png) <br>

예시 코드에서는 `data` 변수의 값에 따라 비순차 메모리 접근이 발생할 대 다른 캐시 라인이 접근됩니다. data를 4096, 4kb로 곱하였기 때문에 `probe_array`에 대한 접근은 4kb 거리를 두고 떨어져있으며, 이 때문에 서로 다른 인덱스에 대한 접근은 항상 **다른 페이지에 대한 접근** 이 됩니다. 또한 데이터를 가져올 때 인접한 데이터도 불러오는 prefetch도 페이지 범위 안에서 작동하기 때문에 캐시된 라인을 통해 `data` 값을 알아낼 수 있습니다. 위 그림에서는 비순차 실행을 수행한 다음 페이지들을 돌며 접근 시간을 측정한 결과입니다. Page 84번에만 cache hit이 발생한 것을 알 수 있는데, 이를 통해 절대 실행될 수가 없는 코드만으로도 microarchitectural state가 변할 수 있다는 사실을 알 수 있습니다.

## Building Blocks of the Attack
이전 섹션에서 다뤘듯이 모든 프로세스의 주소 공간에는 커널의 전체 공간 뿐만 아니라, 유저 공간 전체 메모리, 심지어는 레지스터의 값까지 저장이 됩니다(context switch 할 때 TCB에 저장됨). 물론 이 영역들에 접근하려면 당연히 privileged mode여야 합니다. <br>

![m5](/assets/img/posts/papers/Meltdown_5.png) <br>

본 연구에서는 이러한 `privileged-mode isolation`을 우회하여 공격자가 메모리에 올라가 있는 커널 메모리, 다른 프로세스의 메모리 등을 전부 읽어낼 수 있다는 걸 보여주고자 합니다. 위 그림에서 보여지듯이 Meltdown 공격은 크게 두가지로 구성이 됩니다. 

첫 번째는 CPU가 원래라면 절대 실행될 수 없는 instruction들을 실행하도록 만드는 것입니다. 논문에서는 이전 예시에서 보았단 배열 접근과 같이 비순차적으로 실행되면서 side-effect를 남기는 instruction들을 **일시적 명령어(transient instruction)** 라고 부르기로 하였다. 나아가서 이러한 명령어들의 묶음은 **transient instruction sequence** 라고 부릅니다. 일시적 명령어를 공격에 활용하려면 일시적 명령어들이 반드시 추출하고자 하는 비밀값을 활용해야 합니다. 

두 번째는 이러한 일시적 명령어들이 남긴 흔적들을 architectural state로 가져와 추출한 비밀값을 활용하는 것입니다. 논문에서는 부채널 기법을 통해 만든 **covert channel** 로 이를 구현하고 있습니다. 

### Executing Transient Instructions
커널 페이지와 같이 유저가 접근해서는 안되는 페이지에 접근을 시도하면 exception이 발생하면서 애플리케이션을 종료시키는데, 공격자는 user-inaccessible 영역에 접근하려면 예외를 어떻게 다룰지 정해두어야 합니다. 본 논문에서는 일시적 명령어를 실행한 후 exception이 발생했을 때, 이를 catch하는 **exception handling** 과 일시적 명령어를 실행한 후 흐름을 옮겨 exception이 발생하지 않도록 하는 **exception suppression** 두 가지 접근을 제안하고 있습니다.

#### Exception Handling
제일 단순한 방법은 커널 페이지와 같은 영역에 접근하기 전에 공격 애플리케이션을 `fork` 하여 자식 프로세스가 메모리 접근을 하게 만드는 것입니다. 부모 프로세스는 자식이 접근하고 종료된 다음 부채널 기법을 활용하여 값을 알아낼 수 있습니다. 또 다른 방법은 segmentation fualt 같은 exception을 직접 다루는 **signal handler** 를 설치하여 프로세스를 새로 만들 필요가 없도록 하여 오버헤드를 줄이는 방법입니다.

#### Exception Suppression
**Transactional memory** 는 메모리 접근들을 하나의 원자적 연산으로 묶어 에러가 발생하면 이전 상태로 롤백될 수 있도록 하는 기능을 제공합니다. Transaction 안에서 exception이 발생하면 프로그램이 종료되지 않고 architectural state만 초기화가 됩니다. 또한 절대로 참으로 평가될 수 없는 조건문 뒤에 일시적 명령어들을 배치하여 비정상적인 메모리 접근은 투기 실행을 통해서만 발생하도록 만들 수 있습니다. 이 방법은 `branch predictor`를 사전에 정교하게 학습시켜두어야 합니다.

### Building a Covert Channel
부채널 기법이 하나의 covert channel을 만들어낸다고 생각하면 일시적 명령어들을 채널의 송신부, 캐시 상태의 변화를 관측하여 비밀값을 알아내는 부분을 일종의 수신부라고 생각할 수 있습니다. 본 연구에서는 빠른 속도와 높은 해상도, 낮은 노이즈 등을 이유로 Flush+Reload 기법을 활용합니다. 일시적 명령어들이 메모리에 접근을 하면 그 주소는 캐시에 로드가 되고, 수신부는 시간을 측정하여 어떤 주소가 캐시에 올라갔는지 아닌지를 알아낼 수 있습니다. 즉, 송신부에서는 관측되고 있는 캐시 위의 주소에 접근함으로써 `1비트`를, 접근하지 않음으로써 `0비트`를 송신할 수 있습니다. 이걸 여러개의 캐시 라인으로 확장하면 이전의 toy example처럼 full byte를 한번에 복구해낼 수 있습니다. 그러나 Flush+Reload는 일시적 명령어 실행에 비해 시간이 훨씬 많이 걸리기 때문에 1비트씩 송신하는 것이 훨씬 효율적입니다. 

## Meltdown
#### Attack Setting
Meltdown 공격 시나리오에서 공격자는 타겟 시스템에서 un-privileged 코드 실행 권한을 갖고 있습니다. 머신에 대한 물리적 접근은 필요로 하지 않는다. 나아가서 타겟 시스템은 ASLR, KASLR, SMAP, SMEP 등의 **state-of-art** 소프트웨어 기반 방어 기법들이 전부 적용되어 있고 OS에도 취약점이 없다고 가정합니다. 공격자는 `secret user data`를 노리고 있는 상황입니다. 

### Attack Description
멜트다운은 3 단계에 걸쳐 진행됩니다.
1. 공격자는 원래 접근할 수 없어야 하는 공격자가 선택한 주소의 값이 레지스터에 로드가 됩니다
2. 일시적 명령어들은 레지스터에 로드된 값에 따라 캐시 라인에 접근합니다
3. 공격자는 Flush+Reload 기법을 통하여 접근된 캐시 라인을 식별하고 비밀값을 추출합니다 

위의 과정을 반복한다면 커널 전체의 메모리를 덤프할 수 있습니다. <br>

![m6](/assets/img/posts/papers/Meltdown_6.png) <br>

위의 코드는 일시적 명령어와 송신부의 기본적인 구현을 보여주고 있습니다. C 코드로도 같은 기능을 하도록 구현할 수 있습니다.

#### Step 1: Reading the secret
메인 메모리에서 레지스터로 값을 가져오려면 메인 메모리에 있는 값을 **가상 주소로 참조** 할 수 있어야 합니다. CPU는 가상 주소를 물리 주소로 변환하는 동시에, 가상 주소의 권한 비트를 확인하여 이 주소를 유저가 접근할 수 있는지를 확인합니다. 이전에 다뤘듯이 프로세스의 가상 공간에 커널이 통째로 매핑되어 있기 때문에, 가상 주소는 항상 유효한 물리 주소를 반환하고, CPU가 그 주소에 접근을 할 수 있습니다. 즉, Meltdown 공격은 비순차 실행을 악용하여 커널 주소의 값을 불러오는 순간과 CPU가 권한 에러를 발생시키는 사이의 **time window** 를 활용하여 값을 알아냅니다. 

위의 코드의 line 4에서 rcx에 들어있는 대상 커널 주소를 갖고 rax 레지스터의 lsb에 바이트를 로드합니다. 더 자세하게는 `MOV` instruction이 수집된 후 $\mu$ OP로 디코딩 된 다음 reorder buffer로 보내집니다. 코드의 rax, rcx 레지스터는 비순차 실행을 할 수 있도록 물리 레지스터들로 매핑이 됩니다. CPU의 파이프라이닝 때문에 이미 뒤에 있는 instruction들도 $\mu$ OP로 디코딩 되어 할당이 되어 있을 것입니다. 