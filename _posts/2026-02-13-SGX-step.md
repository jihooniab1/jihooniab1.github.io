---
title: "SGX-Step: A Practical Attack Framework for Precise Enclave Execution Control"
date: 2026-02-13 00:00:00 +0900
categories: [Papers]
tags: [security, side channel, TEE]
permalink: /posts/SGX-step/
math: true
---

# Summary for SGX-Step: A Practical Attack Framework for Precise Enclave Execution Control

## Introduction
지난 몇 년간 보안에 민감한 애플리케이션에게 격리 실행 환경이나 최소한의 TCB를 갖는 enclave를 제공하는 **Protected Module Architectures(PMA)** 에 대한 연구가 활발하게 이뤄졌습니다. 이러한 시스템은 모두 하드웨어나 하이퍼바이저를 통해 OS의 핵심적 기능을 유지하면서 enclave의 코드나 데이터에 직접 접근하지 못하게 막습니다.

그러나 최근 연구들은 높은 권한의 PMA 공격자들이 enclave 내부의 실행을 관측할 수 있는 고해상도, 낮은 노이즈의 채널을 구성할 수 있음을 보여주고 있습니다. 구체적으로는 CPU 캐시, 페이지 테이블, branch prediction unit을 통해 정보를 유출하는 **kernel-level SGX attack** 이 꾸준히 연구되었는데, 이러한 공격들은 OS가 제어할 수 있는 타이머 장치를 활용하여 잦은 enclave 선점(preemption)을 통해 fine-grained 부채널을 구성합니다. 이처럼 victim enclave를 얼마나 정밀하게 interrupt 할 수 있는지가 공격의 시간적 해상도를 결정합니다.

본 연구에서 소개하는 **SGX-Step** 은 임의의 enclave 프로그램을 instruction 단위의 해상도로 single-stepping할 수 있는 최초의 오픈소스 Linux 커널 프레임워크입니다. APIC 타이머와 enclave 페이지 테이블을 유저 공간에서 직접 접근할 수 있도록 하여 enclave 선점 공격의 진입 장벽을 크게 낮추었으며, 이를 통해 기존에 불가능하다고 여겨졌던 공격(예: Zigzagger 방어 무력화)이 실현 가능함을 보여줍니다.

## Background and Related Work
### Attacker Model and Intel SGX
Intel x86 프로세서에 추가된 SGX extension은 하드웨어 기반 격리와 enclave의 `security-critical code`에 대한 원격 증명(attestation)을 지원합니다. 페이지 테이블은 OS가 여전히 관리하지만, 프로세서의 MMU가 enclave 메모리에 대한 외부의 직접 접근을 막습니다. 또한 하드웨어 레벨 암호화를 통해 OS가 보호된 페이지를 swap in/out 하는 것을 허용하면서도 그 내용은 보호합니다.

Enclave 코드는 `user mode(Ring 3)`로 제한되며, enclave 내부의 보호된 메모리와 호스트 애플리케이션의 비보호 주소 공간 모두에 접근할 수 있습니다. Enclave 전용 CPU 명령어를 통해 프로세서를 `enclave mode`로 전환하거나 해제할 수 있습니다. **EENTER** 는 제어 흐름을 외부 애플리케이션에서 enclave 내부의 사전 정의된 위치로 옮기고, **EEXIT**은 enclave를 나가는 데 사용됩니다. Fault나 외부 interrupt가 발생할 때 프로세서는 **Asynchronous Enclave Exit (AEX)** 를 실행하여, enclave 내부의 context를 **State Save Area (SSA)** 에 안전하게 저장한 후 CPU 레지스터를 합성 상태(synthetic state)로 대체하여 ISR로의 정보 유출을 막습니다. AEX는 보호되지 않는 콜 스택에 **Asynchronous Exit Pointer (AEP)** 를 삽입하여, OS가 interrupt handler에서 복귀할 때 enclave 외부의 트램폴린 코드로 돌아가게 합니다. 그 후에는 **ERESUME** 명령어로 중단된 enclave를 재개할 수 있습니다.

SGX는 enclave 개발을 돕기 위해 `debug enclave`와 `production enclave`를 구분합니다. Debug enclave는 ring-0의 EDBGRD/EDBGWR 명령어로 내부 메모리에 접근할 수 있지만, production enclave에서는 이러한 디버그 명령이 무시됩니다. 또한 프로세서가 enclave mode에 있을 때는 performance counter, hardware breakpoint, single-step trap flag(RFLAGS.TF) 등 명시적인 디버깅 수단을 무시합니다.

### Enclave Preemption Attacks
Co-resident 논리 프로세서와 L1 캐시를 활용하여 enclave를 중단시키지 않고도 가능한 공격이 있긴 하지만 이 논문에서는 enclave를 선점하는 공격에만 집중합니다. 

#### Fault-Driven Attacks
[Controlled-Channel](https://jihooniab1.github.io/posts/Controlled-Channel/) 논문은 enclave 페이지에 대한 접근을 제한하여 page fault를 유발하고 enclave로부터 많은 양의 데이터를 추출하는 공격을 소개하였습니다. 뒤이은 연구는 page fault를 활용하여 enclave를 제어하고 스레드 동기화 버그를 악용하였습니다. Page fault는 하드웨어에 의해 결정적으로 트리거되기에 노이즈가 낮지만, 드러나는 주소 정보가 course-grained (4KB) granularity라는 한계가 있습니다.

#### Interrupt-Driven Attacks
최근 연구된 SGX 공격들은 page fault 채널보다 개선된 cache line 단위의 해상도로 정보를 유출합니다. 이러한 공격들은 대부분 victim enclave를 중단시켜 정밀한 부채널 관측을 수행합니다. 일부 연구는 커널 스페이스에서 **local APIC 타이머를 설정** 하여 개선된 시간 해상도로 enclave 캐시 공격을 수행하였으나, 약 3개 명령어마다 중단시키는 수준에 그쳤습니다. 또한 메모리 연산 명령어에만 집중하고 소프트웨어 시뮬레이터에서만 구현·평가되었기에 진정한 single-stepping이라고 할 수는 없습니다.

한편, CPU의 BTB에서 발생하는 cache collision을 악용하여 enclave 내부의 제어 흐름을 추론하는 `branch shadowing attack`도 제안되었습니다. 이 공격은 victim enclave와 세밀하게 정렬된 spy shadow code의 주기적 교차 실행에 크게 의존하며, 커널 패치를 통해 약 50개 명령어 단위로, CPU 캐시를 비활성화하면 약 5개 명령어 단위까지 해상도를 줄일 수 있었습니다.

본 연구진이 이전에 진행한 stealthy page table 기반 공격은 다른 논리 코어에서 실행 중인 spy 스레드가 특정 PTE를 모니터링하다가 접근이 감지되면 프로세서 간 인터럽트를 보내 enclave를 선점하는 방식입니다. 다만 특정 페이지가 접근되었을 때만 선점이 일어나므로, 모든 명령어를 순차적으로 중단시키는 SGX-Step과는 차이가 있습니다.

## Design and Implementation
### APIC Timer Configuration
모든 Intel 프로세서는 해당 코어로 향하는 interrupt를 설정하고 전달하기 위해 **local Advanced Programmable Interrupt Controller(APIC)** 를 갖고 있습니다. APIC는 세 가지 모드로 작동하는 타이머도 포함하고 있습니다.

`one-shot`과 `periodic` 모드에서는 타이머가 MMIO(memory-mapped I/O) 레지스터를 통해 설정됩니다. 구체적으로, initial-count 레지스터에 값을 쓰면 내부의 current-count 레지스터가 초기화됩니다. Local APIC는 CPU의 버스 frequency를 divide-configuration 레지스터에 지정된 값으로 나눈 속도로 current-count를 감소시키며, current-count가 0에 도달하면 인터럽트를 생성합니다. `one-shot` 모드에서는 인터럽트가 한 번만 생성되고, `periodic` 모드에서는 initial-count가 **자동으로 current-count에 다시 복사** 되어 반복됩니다.

`TSC-deadline` 모드에서는 CPU 내부의 타임스탬프 카운터가 **MSR(model-specific register)에 지정된 절대값에 도달** 하면 인터럽트가 생성됩니다. 타임스탬프 카운터는 외부 버스 클락 주파수가 아니라 CPU 사이클 주파수로 동작하기 때문에 훨씬 정밀합니다.

APIC 설정을 용이하게 하기 위해, SGX-Step은 물리적 APIC MMIO 레지스터를 유저 공간의 가상 메모리에 매핑하는 런타임 라이브러리를 제공합니다. 이를 통해 비신뢰 호스트 프로세스가 유저 공간에서 **직접 APIC 타이머를 설정하거나 프로세서 간 인터럽트(IPI)를 트리거** 할 수 있습니다. <br>

![s1](/assets/img/posts/papers/sgxstep_1.png) <br>

위 그림은 SGX-Step 프레임워크를 통해 SGX enclave를 인터럽트하고 재개하는 과정을 나타냅니다.

1. Local APIC 타이머 인터럽트가 enclave 명령어 실행 도중에 도착합니다.
2. 프로세서가 AEX를 실행하여 **실행 context를 SSA 프레임에 저장하고, CPU 레지스터를 초기화** 한 후, 커널 레벨 interrupt handler로 제어를 넘깁니다.
3. `/dev/sgx-step` 커널 모듈은 APIC 이벤트 콜백 리스트에 등록되어 있어 매 타이머 인터럽트마다 호출되고, 이때 spy code를 실행할 수 있습니다. 또한 공격자가 제어하는 debug enclave의 경우, `EDBGRD` 명령어로 SSA 프레임에서 instruction pointer를 읽어올 수도 있습니다.
4. 커널이 유저 공간의 AEP trampoline으로 복귀합니다. 본 연구에서는 SGX SDK의 untrusted 런타임을 수정하여 커스텀 AEP stub(짧은 코드 조각)을 쉽게 등록할 수 있도록 하였습니다.
5. 이 시점에서 공격자는 유저 모드 spy code를 실행한 뒤, 다음 인터럽트를 위해 ERESUME 직전에 APIC 타이머를 재설정하고, **ERESUME(6)** 을 실행하여 enclave를 재개합니다.

### Timer Interval Prediction
타이머 인터벌이 너무 짧으면 ERESUME 도중 인터럽트가 걸려 zero-step이, 너무 길면 multi-step이 발생합니다. 기존 연구들은 커널에서 타이머를 설정하고 유저 모드로 전환 후 enclave를 재개하는 방식이라 그 사이 코드 경로가 길어 jitter가 컸습니다.

SGX-Step은 유저 공간에서 직접 APIC 타이머를 설정함으로써 **예측 구간을 ERESUME 실행 시간으로 단축** 하여 jitter를 크게 줄였습니다. 다만 TSC-deadline 모드는 특권 명령어 WRMSR이 필요해 유저 공간에서 사용할 수 없으므로, one-shot/periodic 모드를 사용하며 이로 인한 낮은 타이머 주파수를 감수합니다.

실험에서는 one-shot 모드, division 2로 설정하였으며, 플랫폼마다 CPU 특성이 달라 두 평가 플랫폼 각각에 대해 debug calibration enclave의 instruction pointer를 확인하며 경험적으로 타이머 인터벌을 도출하였습니다.

### Monitoring Page Table Entries
Single-stepping은 성능에 큰 영향을 미치기 때문에, 공격자는 페이지 폴트 또는 전용 spy thread를 통해 **특정 코드/데이터 페이지에 접근이 감지된 시점부터** single-stepping을 시작할 수 있습니다. APIC 설정과 마찬가지로 SGX-Step은 victim enclave의 PTE를 유저 공간 가상 메모리에 매핑하여, 공격자가 유저 공간에서 직접 페이지 폴트를 유발하거나 enclave의 메모리 접근 패턴을 관찰할 수 있게 합니다.

## Evaluation
![s3](/assets/img/posts/papers/sgxstep_3.png) <br>
SGX-Step의 평가는 전부 상용 SGX 하드웨어에서 수행되었습니다. 첫 번째 플랫폼은 Dell Inspiron 13 7359 랩탑(i7-6500U, 2.5GHz)이고, 두 번째는 Dell Optiplex 7040 데스크탑(i7-6700, 3.4GHz)입니다. 먼저 microbenchmark를 제시한 다음, 기존 방법으로는 불가능했던 두 가지 공격 시나리오를 제시합니다. 공격자 모델에 맞추어 TurboBoost 및 동적 주파수 조절(C-States, SpeedStep)을 비활성화하였고, victim enclave 스레드를 특정 논리 코어에 고정하여 실행 예측 정확도를 높였습니다. 위 테이블은 victim enclave에서 발생한 인터럽트를 분류한 것입니다.

### Single-Stepping Microbenchmark
본 공격의 목적은 메모리 연산이 없는 빠른 instruction들을 포함한 임의의 명령어들을 single-step 하는 것입니다. 이를 평가하기 위해 연속된 NOP로 이뤄진 microbenchmark 환경을 구성하였습니다. NOP는 메모리나 레지스터 연산 없이 제일 비용이 작은 명령어로, 타이머 인터벌의 크기가 조금만 커져도 여러개의 NOP가 실행될 수 있습니다. 그러나 실험 결과 NOP 명령어들에 대해서도 single-step이 잘 작동한다는 것이 드러났고, 이는 다른 임의의 명령어들도 마찬가지로 single-step이 잘 될 수 있음을 의미합니다. 

### Precise Enclave Execution Control Attacks
![s2](/assets/img/posts/papers/sgxstep_2.png) <br>
victim이 하나의 코드 페이지나 데이터 페이지만 접근하는 경우 Fault-driven 공격은 enclaved function으로부터 정보를 추론할 수 없습니다. 위의 코드는 기본적인 `strlen` 구현을 나타내고 있습니다. 컴파일러가 CPU 레지스터를 루프 카운터로 쓰기 때문에 루프 전체가 단일 코드/데이터 페이지만으로 작동할 수 있게 되고 이 때문에 page-fault sequence 만으로는 문자열의 길이를 알아낼 수 없습니다. 

SGX-Step은 strlen 반복문을 single-step하면서 **문자열 데이터 페이지의 PTE accessed 비트를 매 인터럽트마다 확인하고 초기화** 합니다. 또한 single-stepping이 정확하게 이루어지면 인터럽트 횟수만으로도 문자열 길이를 추론할 수 있습니다. 위 그림의 오른쪽 부분은 strlen 함수의 어셈블리를 나타내는데, 본 연구에서는 크기 최적화 플래그인 `-0s`를 넣어 반복문 크기와 메모리 연산 개수를 줄인 상태로 진행하였습니다. 이 경우 정밀한 single-step이 더 어려워집니다. 

실험 환경에서는 `SysTEX 2017`을 처리하는 benchmark enclave를 10,000회 single-step하였습니다. 인터럽트가 발생할 때마다 enclave를 resume하기 직전 유저 공간의 AEP trampoline에서 PTE의 accessed 비트를 조회합니다. 또한 EDBGRD 명령어로 enclave의 전체 instruction pointer 트레이스를 분석하여 인터럽트를 분류하였으며 결과는 Table 1에 있습니다. 실험 결과 총 460,000개의 명령어를 성공적으로 single-step하였고, 소수의 zero-step이 발생하였지만 문자열 PTE의 accessed 비트에 거짓 양성이 없었기 때문에 쉽게 걸러낼 수 있었습니다.

### Defeating Zigzagger
![s4](/assets/img/posts/papers/sgxstep_4.png) <br>

이전에 언급한 branch shadowing 공격은 enclave를 자주 선점하여 shadow probing 코드를 실행하고, **BTB 캐시 충돌** 을 통해 enclave 내부의 실행 흐름을 추론합니다. **Zigzagger** 는 이를 방어하기 위한 컴파일러 기반 방어 기법으로, CMOV를 이용하여 조건 분기의 목적 주소를 난독화하고 **무조건 분기들로 이루어진 트램펄린 시퀀스** 를 통해 간접 분기로 연결합니다. 트램펄린의 점프들이 거의 동시에 실행되기 때문에 공격자가 현재 IP를 파악하기 어렵고, branch shadowing 공격으로도 간접 분기 zz4의 목적 주소를 직접 추론할 수 없다는 것이 핵심입니다.

그러나 SGX-Step을 이용하면 Zigzagger가 적용된 코드에서도 single-step 공격이 가능합니다. 공격자는 zz1~zz3의 각 트램펄린 점프를 하나씩 probe할 수 있으며, zz4의 간접 분기 실행을 탐지한 후 zz2가 실행되는지 확인하면 첫 번째 코드 블록(a != 0)이 실행되었는지 알아낼 수 있습니다.

Zigzagger와 branch shadowing 공격 코드는 공개되어 있지 않기 때문에, Figure 3의 어셈블리를 반복하여 single-step하는 PoC를 평가하였습니다. 실험 결과는 Table 1에서 확인할 수 있으며 두 플랫폼 모두에서 정밀하게 동작하였습니다. 또한 소수의 zero-step이 발생하더라도 enclave가 BTB를 건드리지 않은 상태이므로 실제 branch shadowing 공격에는 영향이 없습니다.

## Discussion
### Attack Resolution and Implications
기존의 enclave preemption 기법들은 CPU 캐시를 비활성화하거나 메모리 연산 명령어에만 집중하는 방식으로 instruction-level granularity를 근사했는데, SGX-Step은 한 번에 하나의 명령어만 실행되도록 보장하여 enclave preemption 기법을 크게 개선하였습니다. 또한 유저 스페이스에서 직접 정밀한 enclave preemption이 가능하게 하여 향후 공격들의 진입 장벽도 낮추었습니다.

이러한 점은 방어 기법 설계에도 중요한 시사점을 줍니다. Zigzagger와 같이 명령어 스트림의 사실상 atomic한 동작에 의존하는 컴파일러 기법만으로는 enclave를 충분히 보호할 수 없습니다. 또한 strlen 공격 예제는 Intel이 공식적으로 권장하는 "코드와 데이터를 단일 페이지 안에 배치하는" 방식도 충분하지 않다는 것을 보여줍니다.

### Detecting Suspicious Interrupts
Sanctum과 같은 PMA와 다르게 SGX는 `interrupt-unaware` 하게 설계되었습니다. 그러나 최근에는 x86 TSX를 활용하여 enclave mode에서의 페이지 폴트나 인터럽트를 감지하는 연구들이 이어지고 있습니다.

T-SGX는 페이지 폴트 기반 공격으로부터 enclave를 보호하기 위해 각 베이직 블록을 TSX transaction으로 감싼 다음, transaction abort가 너무 많이 발생하면 enclave를 중단시킵니다. Déjà Vu는 enclave 내부에 TSX를 활용하는 클락 스레드를 생성하여 OS에서 멈출 수 없게 하면서 enclave 프로그램을 계측하여 잦은 선점을 탐지합니다. 이 두 방식 모두 SGX-Step이 일으키는 잦은 인터럽트를 탐지할 수 있지만 큰 단점이 여럿 있습니다.

먼저 SGX가 활성화 되어 있는 프로세서에 항상 TSX exension이 있지는 않기에 TSX가 없는 enclave들을 보호할 수 없습니다. 두 번째로 TSX 기반 방어 기법은 성능에 큰 악영향을 줍니다. 세 번째로 수상한 인터럽트 비율을 휴리스틱하게 탐지하기 때문에 오탐이 발생할 수 있습니다. 