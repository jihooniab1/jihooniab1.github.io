---
title: "CVE-2020-3118"
date: 2026-02-12 00:00:00 +0900
categories: [1-day]
tags: [security, 1-day]
permalink: /posts/cve-2020-3118/
math: true
---

# CVE-2020-3118 익스플로잇 도전

## 환경 설정
CISCO의 IOS-XRv Router에서 발생한 **CVE-2020-3118** 익스플로잇을 도전해보고자 합니다. 실습은 CISCO에서 배포한 에뮬레이션 이미지를 VMWARE를 통해 에뮬레이션 하여 진행합니다. 이미지들은 아래와 같이 구성이 되어 있는데, CISCO 홈페이지에서도 다운 받는 경로를 찾을 수는 있는데 별다른 계약이나 구매 절차 없이도 구할 수 있는지는 확인해보지 않았습니다. <br>

![2020-31181](/assets/img/posts/1-day/2020-3118_1.png) <br>

ova 이미지를 VMWARE에 import 시킨 다음, 메모리는 10기가 정도 주고 부팅하면 됩니다. 네트워크 어댑터는 vmnet8을 사용하도록 하였습니다. <br>

![2020-31181](/assets/img/posts/1-day/2020-3118_2.png) <br>

기다리다보면 `Press RETURN to get started` 라고 뜨는데, **cisco:cisco** 로 로그인하면 라우터 쉘로 들어가집니다. 먼저 네트워크 인터페이스를 활성화해봅시다. <br>

![20203201182](/assets/img/posts/1-day/2020-3118_3.png) <br>

`show ipv4 interface brief`를 입력하면 존재하는 인터페이스들을 확인할 수 있고, 동작시킬 **관리 전용 인터페이스명** 도 확인할 수 있습니다. 위 캡처에서 보듯이 현재는 IP 주소도 할당되어 있지 않고 전부 Shutdown 상태입니다. <br>

![20203118](/assets/img/posts/1-day/2020-3118_4.png) <br>

위와 같이 conf 모드로 진입한 후, 인터페이스의 IP 주소를 VM 커스텀 네트워크 대역 주소로 변경한 다음 인터페이스를 `up` 상태로 변경하고 commit 하면 됩니다. 그러면 아래와 같이 인터페이스 상태가 변한 것을 볼 수 있습니다. 더 자세하게 얘기하자면 VMWARE의 네트워크 에디터 설정에서 vmnet8의 서브넷 주소가 172.16.208로 되어 있어서 임의로 100을 붙여주었습니다. <br>

![2](/assets/img/posts/1-day/2020-3118_5.png) <br>

이제 **run을 입력하여 내장쉘** 로 진입합니다. 

```
run

$ sysctl -w kernel.randomize_va_space=0 # 1-day 재현을 위한 ASLR 해제
```

![3](/assets/img/posts/1-day/2020-3118_6.png) <br>

그리고 cdp는 기본적으로 비활성화 되어 있기 때문에 위와 같이 명령어를 입력하여 활성화를 해줍니다. 내장 쉘에 들어가서 `ps -ef`로도 확인할 수 있고, 실행 모드에서도 `cdp`를 입력하여 cdp 활성화를 확인할 수 있습니다. <br>

![3](/assets/img/posts/1-day/2020-3118_7.png) <br>

IOS-XRv CLI와 Bash는 다른 네트워크 네임 스페이스에 위치하기 때문에, 실행 모드에서 설정한 네트워크를 이용하려면 **global-vrf 네임스페이스** 에 진입해야 합니다. 내장쉘에 진입할 때마다 이 명령어를 쳐줘야 합니다.
```
run
$ ip netns exec global-vrf bash
```

![3](/assets/img/posts/1-day/2020-3118_8.png) <br>

이런 식으로 gdbserver를 열어둔 다음 호스트에서 gdb를 열고 아래 명령어를 타이핑하면 cdp 프로세스를 디버깅할 수 있습니다.
```
gef> target remote 172.16.208.100:8888
Remote debugging using 172.16.208.100:8888
warning: No executable has been specified and target does not support
determining executable automatically.  Try using the "file" command.
```

디버거가 붙은 직후에는 심볼 정보가 하나도 없을텐데, gdbserver에서 파일 전송 기능을 지원하면 직접 바이너리를 가져올 수도 있습니다. <br>

![3](/assets/img/posts/1-day/2020-3118_9.png) <br>

```
gef> remote get /opt/cisco/XR/packages/xrv9k-iosxr-fwding-5.0.0.0-r642/all/bin/cdp ./cdp
Successfully fetched file "/opt/cisco/XR/packages/xrv9k-iosxr-fwding-5.0.0.0-r642/all/bin/cdp".
```

그리고 **file cdp** 를 타이핑하면 cdp 바이너리의 심볼 정보를 로드할 수 있습니다. 또한 got,plt 정보가 필요할 때 그냥 명령어를 치면 안되고 **base** 명령어를 통해 프로세스 정보를 로드한 다음 
```
gef> got -f cdp -e $codebase
```
이런 식으로 명령어를 써야 합니다. 이 일련의 과정들을 매번 해주기 귀찮으면 `gdbscript`를 구성하고 `gdb cdp -x gdbscript` 이런 식으로 사용할 수 있습니다.

```
target remote 172.16.208.100:8888

base

context
```

## Vulnerability analysis
https://packetstorm.news/files/id/156203 이 보고서를 참고하였습니다.

CVE-2020-3118은 `Cisco Discovery Protocol`에서 발견된 포맷 스트링 버그 취약점으로, 악성 패킷을 전송하여 임의 코드 실행을 이끌어낼 수 있습니다. 취약한 코드 스니펫은 아래와 같습니다.
```c
var = (uint *)calloc(1,(ulong)uVar2);
if (var == (uint *)0x0) {
  DAT_0032bbc8 = DAT_0032bbc8 + 1;
  iVar5 = 0xc;
  if (DAT_00326a88 != 0) {
    buginf(&PTR_PTR_00326a80,0,0,"CDP-ERR: %s: out of memory, mallocing %u bytes",
           "cdp_events_entry_common",uVar2);
  }
}
else {
  *var = param_2;
  uVar3 = FUN_0010ae2e(param_1);
  var[1] = uVar3;
  uVar3 = FUN_0010a7cc(param_1);
  var[2] = uVar3;
  var[3] = *(uint *)(param_1 + 0x54);
  var[4] = (uint)*(byte *)(param_1 + 0x78);
  device_id = (char *)FUN_0010add0(param_1);
  snprintf((char *)(var + 7),0x1e,device_id);
  port_id = (char *)FUN_0010aba0(param_1);
  snprintf((char *)((long)var + 0x3a),0x28,port_id);
  software_version = (char *)FUN_0010abf6(param_1);
  snprintf((char *)((long)var + 0x62),0x20,software_version);
```

snprintf 함수는 포맷된 문자열을 버퍼에 크기 제한을 두고 쓰는 C 함수입니다.
```c
int snprintf(char *buf, size_t size, const char *format, ...);
```

이때 외부 입력을 포맷 스트링 위치에 직접 넣고 쓰고 있어 공격자가 CDP 패킷의 device_id 필드에 악의적인 값을 넣으면 그대로 포맷 스트링으로 해석이 됩니다. 

cdp 패킷의 구조는 헤더와 하나 이상의 TLV(Type, Length, Value) 필드로 구성이 됩니다. 

헤더는 다음과 같습니다.
- Version: CDP 버전 (1바이트)
- Time To Live: TTL 값 (1바이트, 기본 180초)
- Checksum: 체크섬 (2바이트)

헤더가 4바이트입니다.

TLV는 Type(2바이트), Length(2바이트), Value(가변)로 구성되며, 헤더 뒤에 연속으로 붙습니다.

Type 필드는 다음과 같습니다.
- 0x0001: Device ID (장비 호스트명 또는 MAC 주소)
- 0x0002: Address (IP 주소 등 네트워크 주소)
- 0x0003: Port ID (송신 포트 이름)
- 0x0004: Capabilities (장비 기능 비트마스크)
- 0x0005: Version (소프트웨어 버전 문자열)
- 0x0006: Platform (장비 모델명)
- 0x0007: IP Prefix (직접 연결된 IP 네트워크 정보)

취약한 코드에서 사용되는 TLV는 Device ID(0x0001), Port ID(0x0003), Version(0x0005) 세 가지이며, 이들의 Value 값이 snprintf의 포맷 스트링 위치에 직접 전달되고 있습니다.