---
title: "Controlled-Channel Attacks: Deterministic Side Channels for Untrusted Operating Systems"
date: 2026-02-02 00:00:00 +0900
categories: [Papers]
tags: [security, side channel, TEE]
permalink: /posts/Controlled-Channel/
math: true
---

# Summary for Controlled-Channel Attacks: Deterministic Side Channels for Untrusted Operating Systems

## Introduction
운영체제 대신 **trusted computing base (TCB)** 를 활용하여 애플리케이션을 보호하는 **shielding system** 이 활발하게 연구되어 왔습니다. 이러한 시스템은 보통 신뢰할 수 있는 하드웨어나 하이퍼바이저를 활용하여 운영체제가 애플리케이션 메모리를 읽고 쓰거나 실행을 조작하지 못하도록 막습니다. 한편, 신뢰할 수 없는 운영체제라 하더라도 자원 관리나 표준 인터페이스 제공 같은 핵심 기능은 여전히 수행해야 합니다. 이러한 기능이 있어야 멀티태스킹, 페이징, 레거시 애플리케이션 지원이 가능하기 때문입니다. 그런데 레거시 애플리케이션들은 운영체제를 신뢰할 수 있다는 전제 하에 설계되었기 때문에, shielding system이 수정 없이 이들을 보호하려면 운영체제의 모든 적대 행위로부터 격리해야 합니다.

본 연구에서는 shielding system에 대한 새로운 부채널 공격인 **controlled-channel attack** 을 소개합니다. 신뢰할 수 없는 운영체제는 플랫폼에 대한 제어권을 바탕으로 강력한 부채널을 구성할 수 있고, 기존 부채널 공격보다 훨씬 강력한 공격을 가능하게 합니다. 본 연구에서 제안하는 **no-noise channel** 은 전통적인 부채널 공격들과 다르게 노이즈 없이 많은 수의 가상 주소를 동시에 모니터링하고 높은 해상도로 이벤트를 관측할 수 있어, 단일 실행만으로도 대량의 데이터를 추출할 수 있습니다.

본 연구에서 제안하는 no-noise channel은 애플리케이션의 메모리 접근으로 인해 발생하는 **page fault** 를 활용합니다. 레거시 애플리케이션을 대상으로 하는 만큼 바이너리가 공개되어 있다고 가정하고, 메모리 접근 패턴에 대한 사전 분석을 바탕으로 공격을 수행합니다. 공격자는 먼저 바이너리가 로드된 베이스 주소를 추론한 뒤, **페이지 테이블을 조작** 하여 특정 코드나 데이터 페이지를 접근 불가 상태로 만듭니다. 이후 애플리케이션이 해당 페이지에 접근하면 page fault가 발생하고 운영체제가 호출되는데, 이 과정에서 어떤 페이지에 접근했는지 기록할 수 있어 애플리케이션의 페이지 접근 트레이스를 수집할 수 있습니다.

공격에는 두 가지 주요 장애물이 있습니다. 첫째, 메모리 접근을 4KB 페이지 단위로만 관측할 수 있다는 점입니다. 둘째, page fault는 비용이 큰 연산이기 때문에 단순하게 공격을 수행하면 오버헤드가 크게 증가한다는 점입니다. 본 연구에서는 페이지 단위 제약 하에서도 공격을 수행할 수 있는 기법과 오버헤드를 적정 수준으로 줄이는 최적화 기법을 함께 제시합니다.

## Background and Attack Model
Shielding system의 목표는 레거시 애플리케이션을 기존 OS 위에서 실행하되 OS를 신뢰하지 않아도 되게 하는 것입니다. 주로 하이퍼바이저나 보안 하드웨어로 구성된 **high privileged monitor component** 가 운영체제의 애플리케이션 개입을 차단합니다. 이를 위해 모니터는 암호화된 디스크 스토리지 등을 통해 애플리케이션을 안전하게 초기화할 수 있어야 하고, 보호된 애플리케이션을 위한 **격리 실행 환경** 을 제공해야 합니다. 하이퍼바이저 기반 시스템은 운영체제의 페이지 테이블 수정을 가로채서 애플리케이션 메모리에 대한 접근을 차단하는 방식으로 이를 구현합니다. 애플리케이션의 가상 주소 공간 레이아웃의 무결성을 보호하는 데에도 같은 기법이 사용됩니다. 또한 모니터는 애플리케이션과 OS 사이의 컨텍스트 스위치에 개입하여 애플리케이션 상태가 운영체제에 노출되지 않도록 해야 합니다.

### A. Attack Model
공격자 모델에서는 공격자가 운영체제를 제어할 수 있지만, monitor component나 보호된 환경에서 실행되는 애플리케이션 코드는 조작할 수 없다고 가정합니다. 본 논문에서 대상으로 하는 shielding system의 특성은 다음과 같습니다.

#### Memory resource management by the operating system
운영체제는 자원 관리의 일환으로 가상-물리 주소 매핑을 관리합니다. Shielding system은 운영체제가 애플리케이션 메모리를 읽거나 쓰지 못하게 하고, 주소 공간의 무결성을 보장하도록 제약을 가할 수 있습니다. 그러나 운영체제는 swap 등을 위해서 **물리 페이지를 회수하여 가상-물리 매핑을 제거** 할 수 있고, page fault 처리를 위해 매핑을 복구할 수도 있어야 합니다. 이를 위해 운영체제는 page fault가 발생한 페이지의 가상 주소(page base)를 알 수 있어야 합니다.

#### Applications
본 연구에서는 레거시 애플리케이션의 바이너리가 공개되어 있으며, 공격자가 타겟 바이너리의 정확한 버전을 알고 있다고 가정합니다. 이러한 애플리케이션들은 메모리 접근 패턴을 숨기기 위한 별도의 조치를 취하지 않습니다. 본 연구에서는 소스 코드 수준에서 애플리케이션을 분석하여 공격을 수행합니다.

## Design
공격의 핵심 아이디어는 애플리케이션이 처리하는 데이터에 따라 control transfer나 data access에서 서로 다른 패턴을 보인다는 점입니다. 이를 **input-dependent control transfer, input-dependent data access** 라고 부릅니다. 이를 관측하기 위해 운영체제는 특정 코드나 데이터 페이지를 접근 불가 상태로 만들어 **page fault trap을 유도(induce)** 할 수 있습니다. Page fault가 발생하면 해당 주소를 통해 제어 흐름이나 메모리 접근을 파악할 수 있습니다. 공격 설계에서 가장 큰 문제는 page fault 주소의 하위 12비트가 항상 0으로 마스킹되어, 페이지 내에서 정확히 어디에 접근했는지 직접 알아낼 수 없다는 점입니다.

### A. Basic Attack
```c
/* Example for input-dependent control transfer */
char* WelcomeMessage ( GENDER s ) {
    char *mesg;

    if (s == MALE){
        mesg = WelcomeMessageForMale();
    }
    else {
        mesg = WelcomeMessageForFemale();
    }
}
```

위 예시에서 `WelcomeMessage`와 다른 두 함수는 **다른 코드 페이지** 에 있다고 가정합니다. 두 함수가 있는 코드 페이지에 대한 접근을 제한해둔 다음, 둘 중 하나가 호출되면 페이지 폴트가 트리거되면서 어느 함수가 호출되었는지를 보고 사용자의 성별 정보를 유추할 수 있게 됩니다. 공격자는 byte-granular page-fault 주소를 알 수 있다고 가정합니다.

```c
/* Example for input-dependent data access */
void CountLogin( GENDER s ) {
    if (s == MALE){
        gMaleCount ++;
    }
    else {
        gFemaleCount ++;
    }
} 
```

위 예시에서는 두 전역 변수를 통해 남성과 여성의 로그인 횟수를 카운팅하고 있습니다. CountLogin 함수는 실행 코드이므로 코드 페이지에, 두 전역 변수는 쓰기 가능한 데이터이므로 데이터 페이지에 위치합니다. 해당 페이지들을 접근 불가 상태로 만들어 두었을 때 변수 접근 시 page fault가 발생합니다. 어느 페이지에서 fault가 발생했는지를 통해 사용자의 성별을 알 수 있고, 각 페이지의 fault 횟수를 세면 남성과 여성 사용자의 총 수도 알아낼 수 있습니다.

페이지 폴트의 정확한 주소가 주어진다면 어느 함수가 호출되었는지, 어떤 변수에 접근했는지를 바로 알아낼 수 있습니다. 하지만 **주소가 페이지 단위로만** 주어질 경우 이를 직접 파악할 수 없습니다.

### B. Inferring Input-Dependent Memory Accesses
공격의 첫 번째 단계는 애플리케이션 코드를 분석하여 **어떤 제어 흐름이나 데이터 접근이 입력에 의존하는지 식별** 하는 것입니다. 본 연구에서는 바이트 단위의 자세한 주소가 주어지지 않아도 어떤 함수 호출이나 데이터 접근에 대해서 **고유한 페이지 폴트 시퀀스** 를 식별하는 방식으로 접근 주소를 알아내었습니다. 

고유한 페이지 폴트 시퀀스를 식별하기 위해, **shielding system 없이** 애플리케이션을 실행합니다. 모든 페이지에 접근 제한을 걸어두고, 페이지 폴트 발생 시 해당 주소를 기록한 뒤 접근을 허용하는 방식으로 바이트 단위의 전체 페이지 폴트 트레이스를 수집합니다. 각 페이지 폴트에 대하여, 접근을 통해 페이지 폴트를 유발한 주소를 **page-fault address**, 페이지 폴트가 발생했을 때 실행되는 명령어 주소를 instruction address of the page fault 라고 합니다. 명령어가 두 메모리 페이지에 걸쳐있거나, page-fault address가 두 번째 페이지에 있는게 아니라면 코드 페이지 폴트 상황에서 두 주소는 같습니다. 

#### Control transfers
제어 흐름을 추론하기 위해서는 `코드 페이지의 page fault`를 기록합니다. $P_i$는 i번째 트레이스, $p_i^j$는 i번째 트레이스의 j번째 `page-fault address`를 나타낸다고 할 때 페이지 폴트 트레이스의 집합인 $\{P_i = \{p_i^j\}\}$가 수집되었다고 가정을 해봅시다. **더 나은 애플리케이션 실행 흐름 경로의 커버리지** 를 위해 페이지 폴트 트레이스를 여러개 수집합니다. 또한 바이너리들은 실행될 때마다 다른 주소에 로드될 수 있기 때문에, page-fault address를 모듈 오프셋으로 변환합니다.

각 트레이스 $P_i$에 대해 새로운 트레이스인 $Q_i = \{q_i^j\}$를 생성하는데, 이때 $q_i^j$는 i번째 트레이스의 j번째 페이지 폴트의 페이지 베이스 주소입니다. 공격에서 얻을 수 있는 트레이스는 $Q_i$입니다. $f$를 식별하고자 하는 제어 흐름의 타겟 주소라고 합시다. $p_s^t = f$인 모든 s, t에 대해, **제일 작은 k ≥ 1** 을 찾습니다. 이 k는 다음 조건을 만족해야 합니다: 임의의 시퀀스 $(q_i^{j-k+1}, \dots, q_i^j)$가 $(q_s^{t-k+1}, \dots, q_s^t)$와 일치할 때, **항상** $p_i^j = f$여야 합니다. 즉, 해당 페이지 시퀀스가 나타나면 **반드시 f 호출임을 보장** 하는 최소 길이의 시퀀스를 찾는 것입니다. 함수 f가 여러 곳에서 호출될 수 있기 때문에, f에 대한 고유 시퀀스는 하나 이상 발견될 수 있습니다. 마지막으로 고유한 시퀀스 집합인 $\{(q_s^{t-k+1},\dots,q_s^t)\}$를 활용하여 제어 흐름을 식별합니다. <br>

![c1](/assets/img/posts/papers/controlled_1.png) <br>

위 그림은 같은 페이지를 공유하는 두 함수가 어떻게 page-fault sequence에 의해 구별될 수 있는지 나타내고 있습니다. 

#### Data accesses
특정 메모리 주소에 대한 데이터 접근을 추론하기 위해, shielding system 없이 코드와 데이터 페이지 모두에서 바이트 단위 페이지 폴트 트레이스를 기록합니다. 먼저 특정 주소 접근으로 인해 발생하는 data page fault들을 식별합니다. 그 다음, 각 data page fault **직전에 발생하는 code page fault 시퀀스** 중 해당 데이터 접근을 고유하게 식별할 수 있는 최소 길이의 시퀀스를 찾습니다. 동적으로 할당되는 데이터의 경우 실행 전에는 주소를 알 수 없지만, 해당 데이터에 접근하는 **명령어의 위치**는 오프라인 분석으로 알 수 있으므로 동일한 기법으로 접근을 식별할 수 있습니다. 

### C. Handling Page Faults
#### Code pages
타겟 프로세스의 모든 코드 페이지를 추적하면 가장 많은 정보를 얻을 수 있지만, 공격이 매우 느려집니다. 대신 오프라인 분석에서 식별한 `page-fault sequence`에 포함된 페이지들(고유 시퀀스에 포함된 페이지들)만 **tracking pages**로 설정하고, 애플리케이션 실행 시 이 페이지들에 대한 접근을 제한합니다. 페이지 폴트 발생 시 이를 기록하고, 해당 페이지 접근을 허용한 뒤 이전 페이지를 다시 제한합니다.

그런데 이 방식은 **false positive** 문제가 발생할 수 있습니다. 예를 들어 고유 시퀀스 $(p_a, p_c)$가 있을 때, 실제 접근 순서가 $(p_a, p_b, p_c)$라면 원래는 매칭되지 않아야 합니다. 하지만 $p_b$가 tracking pages에 없으면 $(p_a, p_c)$로 관찰되어 잘못된 매칭이 발생합니다.

이를 해결하기 위해, shileding system 밖에서 얻은 전체 트레이스를 **tracking pages 기준으로 축소** 합니다. 추적하지 않는 페이지는 제거하고 연속된 동일 페이지는 병합한 뒤, 이 축소된 트레이스에서 false positive를 유발하는 시퀀스를 찾습니다. $(p_a, p_b, p_c)$처럼 중간에 빠진 페이지가 문제가 되면, $p_b$를 tracking pages에 추가합니다.

또 다른 문제는 **명령어가 두 페이지 경계에 걸쳐 있는 경우**입니다. 두 페이지가 모두 tracking pages라면, 한 페이지를 허용하고 다른 페이지를 제한하는 과정에서 무한 루프에 빠질 수 있습니다. 이 경우 연속된 두 페이지에서 폴트가 반복되면 두 페이지 모두 접근을 허용하고, 다음 폴트 발생 시 둘 다 다시 제한합니다. 

#### Data pages
특정 함수 실행 중에만 data page fault를 추적하면 되는 경우가 많습니다. 이때 code page-fault sequence를 활용하여 함수의 시작과 끝을 감지하고, 그 사이에서만 data page fault를 추적합니다.

Data page fault 발생 시, 이전 data page에 대한 접근 제한을 다시 걸지 않아도 되는 경우가 있습니다. 특정 데이터 접근이 발생했는지 여부만 확인하면 되는 경우입니다. 반면 함수 내에서 **데이터 접근 횟수까지** 알아야 한다면, 이전 data page를 다시 제한해서 반복적인 page fault를 유발해야 합니다.

x86-64 명령어는 최대 두 개의 메모리 위치에 접근할 수 있습니다. 예를 들어 `call [funcptr]`은 함수 포인터를 읽고 스택에 리턴 주소를 씁니다. 최악의 경우 두 메모리 접근이 각각 두 페이지에 걸쳐 있으면, 네 개의 data page fault를 처리하고 모두 접근을 허용해야 명령어가 실행됩니다.

## Attacks
### FreeType
FreeType은 텍스트를 비트맵으로 렌더링하는 유저레벨 폰트 라이브러리입니다. 다양한 폰트 형식을 지원하는데, 본 연구에서는 가장 흔하게 사용되는 **TrueType** 폰트에 대해 공격을 진행합니다. TrueType 폰트에서 문자의 **글리프(glyph)** 는 선과 곡선 명령어들의 집합과 힌트들의 집합으로 표현되며, FreeType은 이 명령어들을 실행하고 힌트들을 처리하여 글리프를 비트맵에 그립니다. 글리프마다 명령어와 힌트가 다르기 때문에 렌더링 시 제어 흐름도 달라집니다. 이를 이용하여 렌더링되는 텍스트를 추론할 수 있습니다.

TrueType 렌더링 함수인 **TT_Load_Glyph** 는 문자를 렌더링할 때마다 호출됩니다. 먼저 이 함수의 시작과 끝을 감지할 수 있는 두 개의 page-fault sequence를 식별합니다. 그 다음, 모든 코드 페이지를 추적하는 대신 **TT_Load_Glyph 호출당 page-fault 횟수** 가 각 문자를 고유하게 식별할 수 있도록 추적할 코드 페이지의 부분집합을 선정합니다. 실제 공격에서는 식별해둔 시퀀스로 함수의 시작과 끝을 감지하고, 그 사이의 page-fault 횟수를 오프라인 분석 결과와 비교하여 각 문자를 식별합니다.

### Hunspell
Hunspell은 많은 소프트웨어 패키지에서 널리 사용되는 맞춤법 검사 도구로, dictionary의 단어들을 메모리의 해시 테이블에 로드하고, 단어가 해시 테이블에 있는지를 확인하여 맞춤법을 검사합니다. 해시 테이블은 분리 연결법 방식으로 해시 충돌을 처리하는데, 연결 리스트들을 가리키는 포인터 배열로 구성되고 배열의 인덱스는 해시값입니다. 각 연결 리스트에는 같은 해시값을 가진 단어들이 들어있습니다. 해시 테이블 예시는 아래 그림에서 확인할 수 있습니다. <br>

![c2](/assets/img/posts/papers/controlled_2.png) <br>

해시 테이블에 단어를 삽입할 때, Hunspell은 연결 리스트를 가리키는 포인터가 있는 페이지와 연결 리스트 노드가 있는 페이지 등 여러 data page에 접근합니다. 단어를 lookup할 때도 삽입할 때와 **같은 data page들을 같은 순서로 접근** 합니다. 따라서 어떤 단어가 삽입될 때 접근하는 data page sequence를 알면, lookup 시 같은 sequence를 관찰하여 어떤 단어를 검색하는지 알 수 있습니다. Hunspell은 dictionary의 단어들을 순차적으로 삽입하므로 삽입 순서도 알 수 있습니다.

Hunspell에서 `HashMgr::add_word` 함수가 삽입을, `HashMgr::lookup` 함수가 lookup을 수행합니다. 각 함수의 시작과 끝을 추론할 수 있는 4개의 page-fault sequence를 식별하였습니다. 실제 공격에서는 각 함수가 호출되면 모든 data-page access를 기록합니다. 오프라인 분석에서 사전의 각 단어가 어떤 순서로 data page에 접근하는지 기록해두고, 이를 기반으로 lookup되는 단어들을 추론합니다. 참고로 data page fault 발생 시 이전 data page를 다시 제한하지는 않습니다.

Hunspell이 해시값이 같은 두 단어를 삽입할 때 **같은 data page sequence** 가 나타날 수 있어 모호성이 발생할 수 있습니다. 그러나 단어의 해시값과 사전에서의 위치 간 상관관계가 낮기 때문에 모호성은 드물게 발생합니다. 모호성이 발생하는 경우에는 언어 모델을 활용하여 어떤 단어가 더 적합한지 판단합니다. 

Hunspell은 접사를 지원하여 단어를 찾지 못하면 접사를 제거하고 다시 검색하는데, 이 경우 하나의 입력 단어에 대해 여러 번의 lookup이 발생할 수 있습니다. 이를 처리하기 위해 문서의 각 단어마다 정확히 한 번 호출되는 `Hunspell::spell` 함수도 추적하여, 마지막 lookup 결과만 출력합니다.

### JPEG
JPEG은 널리 사용되는 이미지 손실 압축 표준입니다. 원본 비트맵 이미지가 주어질 때, JPEG 인코더는 우선 이미지를 `8 x 8` 픽셀 크기의 블록으로 나눕니다. 그 후 각 블록에 대하여 **이산 코사인 변환** 을 수행합니다. 변환 결과인 8 x 8 크기의 계수 행렬(coefficient matrix)는 **양자화(quantization)** 과정을 거쳐 **compressions** 이 됩니다. 양자화는 유일한 손실 연산을 수행합니다. JPEG 이미지를 디코딩하려면 **decompress 후에 dequantize** 를 하여 계수 행렬을 복구해냅니다. 그 후 각 행렬에 대해 **역이산 코사인 변환(inverse cosine transform, IDCT)** 을 수행하여 비트맵 블록들을 구하고 이를 합쳐 이미지를 만들어냅니다. <br>

![c3](/assets/img/posts/papers/controlled_3.png) <br>

Libjpeg에는 IDCT 구현이 여러가지 있으나 기본 구조는 동일합니다. IDCT가 2차원 연산인만큼, 이중 for문이 8x8 계수 행렬을 돌면서 연산을 수행합니다. Libjpeg에서 사용되는 기본 IDCT 함수는 위 그림의 코드인 **jpeg_idct_islow** 로, 본 공격에서는 이 함수를 대상으로 하여 IDCT 함수의 **성능 최적화 분기** 를 이용하여 공격을 수행합니다. 행이나 열에서 **첫 번째 원소(DC 계수)를 제외한 나머지 AC 계수가 모두 0이면 계산이 크게 단순화되는데**, libjpeg의 IDCT 함수는 이 조건을 먼저 확인하고 해당되면 간소화된 계산을 수행합니다. 복잡한 계산 경로는 단순한 경로보다 훨씬 많은 데이터 페이지 접근을 발생시킵니다. 따라서 IDCT 함수 실행 도중 한번에 하나의 data page에만 접근할 수 있도록 data page fault를 처리하면, 페이지 폴트 횟수를 통해 블록의 상수 행/열 개수를 알아내어 블록의 상대적 복잡도를 추론할 수 있습니다. 

공격 결과, 각 블록의 복잡도를 픽셀 값으로 변환하면 **edge detection과 유사한 윤곽선 이미지** 를 얻을 수 있습니다. 복잡한 블록(경계선 등)은 더 많은 페이지 폴트를 발생시키고, 단순한 블록(균일한 영역)은 적은 폴트를 발생시키기 때문입니다. 컬러 이미지의 경우 각 색상 컴포넌트(YCbCr 또는 RGB)가 별도로 인코딩되어 IDCT가 블록당 여러 번 호출됩니다. 공격자는 색공간을 모르지만, 몇 가지 일반적인 색공간을 가정하여 복원을 시도한 후 가장 좋은 결과를 선택합니다. 복원된 이미지의 차원을 파악하기 위해서는 블록 행마다 호출되는 `decompress_onepass` 함수의 호출 횟수를 추적하여 행의 수를 알아냅니다.

### ASLR
Shielding system이 ASLR을 도입하여 실행 파일들의 로드 주소를 랜덤화하면 공격이 어려워집니다. 그러나 모든 프로그램은 **시작할 때 실행되는 첫 코드(로더, 각 바이너리의 엔트리 포인트)** 가 정해져 있습니다. 따라서 프로세스 시작 시 처음 발생하는 몇 개의 page fault 패턴을 관찰하면 어떤 실행 파일인지 식별할 수 있고, 해당 폴트 주소로부터 각 모듈의 base 주소를 역산할 수 있습니다. 모든 메모리 영역을 접근 불가능하게 해두고 프로세스를 실행하면, **로더에서 가장 먼저 page fault** 가 발생합니다. 그 후에 다른 곳에서 발생하는 page fault는 **로더가 올리는 바이너리의 메모리** 이므로, 이 과정을 통해 각 실행 파일의 로드 주소를 알아낼 수 있습니다. Delayed loading 등으로 늦게 로드되는 바이너리의 경우, 새롭게 매핑되는 메모리 영역을 접근 불가 처리하고 처음 몇 개의 code page fault를 추적하여 동일한 방식으로 식별합니다. 

## Implementation
### A. Implementation of controlled-channel attacks on Haven
Haven은 Intel SGX에 의존하여 운영체제에 제약을 걸고 애플리케이션을 위한 **격리된 실행 환경(enclave)** 을 제공합니다. Enclave 외부에는 메모리 관리와 SGX와의 통신을 위한 untrusted driver, 인터페이스를 제공하는 untrusted usermode runtime이 있습니다. Haven enclave 내부는 보호하고자 하는 Windows 애플리케이션, **Drawbridge library OS**, **Shield 모듈**로 구성됩니다. Drawbridge는 Windows 유저 모드 라이브러리와 유저모드 커널로 구성되며, 애플리케이션에게 Windows 인터페이스를 제공하면서도 실제 호스트 OS에 대한 의존성은 매우 작습니다. Shield 모듈은 파일 시스템 암호화 및 무결성 검증 등의 방법으로 호스트 OS와의 남은 상호작용을 보호합니다. 

SGX는 CPU 성능 카운터를 이용하여 enclave에 대한 부채널을 구성하지 못하도록 막는 side-channel protection이 있습니다. SGX 설계에 맞는 small-TCB 보안 애플리케이션은 소프트웨어 레벨에서도 부채널에 대한 대비를 하기 때문에 충분하지만, 본 연구에서 대상으로 하는 legacy software들은 부채널에 대한 대비가 되어 있지 않습니다. 본 논문의 공격은 Haven의 세 가지 특성에 의존합니다.

첫 번째로, SGX는 호스트 OS가 페이지 테이블을 전부 조작할 수 있도록 하되 새롭고 독립적인 메모리 보호 메커니즘(EPC, EPCM..)을 도입하여 enclave 메모리 접근을 차단합니다. 따라서 공격 코드는 **페이지 테이블을 원하는 대로 수정** 하여 page fault를 유발할 수 있습니다. 두 번째로, enclave 실행 중 page fault가 발생하면 SGX가 CPU 레지스터 context를 저장한 다음, IDT에 명시된 **OS page fault handler** 로 제어를 넘깁니다. 이때 SGX는 fault가 발생한 주소의 하위 12비트를 0으로 만들어서 운영체제에 전달합니다. 세 번째로, Shield 모듈은 enclave 내부의 **메모리 영역을 map/unmap하거나 페이지 접근 권한을 변경** 할 때 OS에 요청해야 하는데, 이를 통해 공격자는 enclave의 정밀한 메모리 레이아웃을 알아낼 수 있습니다. 메모리 영역 매핑 요청은 바이너리가 로드되는 주소뿐만 아니라 로드되는 시점에 대한 정보까지 제공하므로, 공격자는 Drawbridge가 자유롭게 부팅되도록 두었다가 타겟 바이너리가 로드되면 페이지 접근 추적을 활성화하는 방식으로 공격할 수 있습니다.

SGX는 enclave 코드가 유저 모드에서만 실행되도록 제한하는데, enclave 메모리 권한을 수정하는 명령어는 커널 모드에서만 실행할 수 있도록 설계가 되어 있기 때문에 Shield 모듈은 메모리 매핑과 같은 메모리 관리를 위해서는 무조건 OS를 호출해야 합니다. 공격을 수행할 때는 Shiled 모듈이 보내는 메모리 매핑 요청을 처리하는 **Haven의 untrusted driver에 있는 핸들러 함수를 수정** 하여 타겟 모듈이 로드되는 것을 탐지하도록 하였습니다. 효율성을 위해 페이지를 수정할 때 Windows API 함수를 사용하지 않고 직접 페이지 테이블 구조체를 수정하여 **reserved bit** 를 설정하여 page fault를 유발하는 방법을 사용하였습니다. 

Page table shootdown(멀티코어 환경에서 페이지 테이블 수정할 때 다른 코어들의 TLB 무효화)을 방지하기 위해 타겟 애플리케이션 프로세스를 단일 코어에 고정하고 진행하였습니다. 또한 page fault를 처리할 때 OS의 불필요한 코드를 실행하지 않고 공격에 필요한 루틴을 빠르게 실행할 수 있도록 IDT를 덮어 **커스텀 page-fault handler** 를 설치하였습니다. Fault가 공격 때문에 발생한 것인지 한단한 다음, 핸들러는 page fault를 처리, 로깅하고 접근 제한을 조정하는 공격별 프로시저를 호출합니다. 

### B. Implementation of controlled-channel attacks on InkTag
InkTag는 trusted hypervisor를 활용하여 애플리케이션을 보호합니다. 애플리케이션은 **high-assurance process (HAP)** 에서 작동하며, 하이퍼바이저는 HAP의 메모리 페이지 내용을 암호화와 해시를 통해 보호합니다. 메모리 관리는 OS가 수행하지만, 애플리케이션이 요청한 메모리 매핑만 처리되는 것을 보장하기 위해 InkTag는 OS가 HAP의 페이지 테이블을 직접 수정하는 것을 막고, hypercall을 통해 OS의 요청을 검증한 후 페이지 테이블을 업데이트합니다. InkTag에서의 공격은 다음 특징들에 의존합니다.

첫 번째로, InkTag는 OS가 페이징 목적으로 메모리 페이지를 map/unmap 하는 것을 허용합니다. 이를 이용하여 present bit를 클리어하는 방식으로 메모리 페이지가 page out된 것처럼 보이게 하여 접근을 제한할 수 있습니다. 두 번째로, InkTag는 HAP의 page fault를 OS에서 처리하게 합니다. SGX와 달리 하이퍼바이저는 page fault의 전체 주소를 OS에 전달합니다. 세 번째로, InkTag는 HAP에 사용되는 모든 코드가 정적 라이브러리로 컴파일되고 고정된 가상 주소에 로드되기 때문에 ASLR을 신경 쓸 필요가 없습니다.

본 연구에서는 리눅스의 x86-64 page fault 핸들러를 수정하여 InkTag에 대한 controlled-channel attack을 구현하였습니다. 페이지에 대한 접근을 제한할 때는 실제로 메모리에서 내보내지 않고 페이지 테이블의 present bit를 클리어하는 방식을 사용하였습니다. Page fault가 발생하면 먼저 공격에 의해 조작된 페이지인지 확인한 다음, 해당하면 공격 프로시저에 따라 처리하였습니다.

### C. Implementation of Attacks against Applications
본 연구에서는 Haven과 InkTag 환경에서 FreeType, Hunspell, libjpeg에 대한 제어 채널 공격을 구현하였습니다. 공격 환경을 구축하기 위해 몇 가지 제약 사항을 해결하고 실험 조건을 설정하였습니다.

첫 번째로, 공식 바이너리를 그대로 사용할 수 없어 소스 코드를 직접 컴파일하였습니다. Haven의 경우 최신 버전의 공식 윈도우 바이너리가 부재했고, InkTag는 오직 리눅스 콘솔 앱 및 단일 정적 바이너리 형태만 지원하기 때문에 이에 맞춰 uClibc 툴체인과 GCC를 사용해 빌드하였습니다.

두 번째로, 공격의 민감도를 고려하여 컴파일러 최적화를 적용하였습니다. 함수 인라이닝(inlining)이나 동일 페이지 내 코드 배치 등은 제어 흐름 추적을 방해할 수 있지만, 실험의 현실성을 위해 일반적인 상용 환경과 동일한 옵션을 그대로 사용하였습니다. 이는 공격이 최적화된 실제 소프트웨어에서도 유효함을 입증하기 위함입니다.

세 번째로, 각 라이브러리를 구동하기 위한 콘솔 드라이버 애플리케이션을 직접 제작하였습니다. FreeType은 입력 텍스트를 Times New Roman 폰트로 렌더링하도록 했고, Hunspell은 기본 제공되는 영어 사전을 통해 맞춤법을 검사하게 하였으며, libjpeg은 JPEG 이미지를 디코딩하여 BMP 파일로 변환하는 과정을 거치도록 설계하였습니다.

### D. Implementation of the ASLR attack on Windows
본 연구의 ASLR 공격은 Haven과 InkTag가 ASLR을 지원하지 않는 점을 고려하여 Windows 환경에서 구현되었습니다. 공격은 타겟 프로세스를 식별하고 메모리 배치를 추적하기 위해 커널 수준에서 정밀하게 설계되었습니다.

첫 번째로, 윈도우 커널 API를 활용하여 타겟 프로세스와 메모리 영역을 추적합니다. `PsSetCreateProcessNotifyRoutineEx`를 통해 프로세스 생성을 감시하고, `PsSetLoadImageNotifyRoutine`을 사용하여 실행 파일이 로드되는 메모리 위치를 실시간으로 식별합니다. 두 번째로, 페이지 테이블을 직접 조작하되 Non-Executable(NX) 비트(63번 비트)를 활용하여 접근을 제한합니다. 이는 데이터 페이지 접근 시 발생하는 불필요한 페이지 폴트를 방지하고, 오직 코드가 실행(Execution)되는 순간에만 트랩이 발생하도록 하여 공격의 효율성을 높이기 위함입니다.

## Evaluation
공격은 Haven, InkTag 두 환경에서 수행되었습니다. FreeType 공격은 텍스트를 **100% 정확하게** 복구했고, Hunspell 공격은 언어 모델 적용 후 **약 89%**의 단어를 정확히 복구했습니다. libjpeg 공격은 이미지의 윤곽선을 알아볼 수 있을 정도로 복구했습니다. 성능 오버헤드는 Haven에서 약 3~25배, InkTag에서 약 32~355배 수준이었으나, 실제 사용 환경에서는 네트워크 지연이나 사용자 입력 대기 등의 시스템 노이즈에 묻어갈 수 있는 수준입니다.

## Discussion and Mitigation
기존의 부채널 공격들처럼 controlled-channel attack 역시 메모리 접근 패턴에 의존하기 때문에, 기존 공격들에 대한 mitigation이 controlled-channel attack에도 적용될 수 있습니다. 애플리케이션 레벨에서는 메모리 접근 패턴이 민감한 데이터에 의존하지 않도록 재설계하는 방법이 있으나 굉장히 소모적이고 어렵습니다. 시스템 레벨에서는 애플리케이션 일부분에 대한 페이징을 차단하는 방법이 있을 수 있습니다. 예를 들어 OS가 애플리케이션 바이너리의 executable page에 대한 페이징을 못하도록 막으면 본 논문에서 제시하는 공격을 차단할 수 있습니다. OS는 애플리케이션이 메모리를 얼마나 사용할지만 관리하고 페이징은 애플리케이션이 직접 수행하는 **self-paging** 기법이 제안된 적도 있는데, 이를 도입하려면 하드웨어나 시스템을 많이 수정해야 합니다. 노이즈나 ORAM 기술을 통해 애플리케이션의 메모리 접근 패턴을 숨기거나, fine-grained ASLR로 바이너리의 레이아웃을 섞어버리는 방법도 생각해볼 수 있습니다. 애플리케이션이나 shielding system에서 공격의 artifact를 탐지하여 대응하는 방안도 생각해볼 수 있지만, mitigation과 오버헤드 사이의 트레이드오프는 더 연구가 필요합니다. 

## Related Work
### A. OS를 TCB에서 제외하는 연구
복잡한 상용 OS의 보안 취약점 문제로 인해 OS를 TCB에서 제외하려는 연구가 진행되어 왔습니다. 첫 번째 방향은 Flicker, TrustVisor, MiniBox처럼 TCB를 최소화하고 작은 보안 애플리케이션을 대상으로 하는 연구들이고, 두 번째 방향은 Overshadow, InkTag, Haven처럼 레거시 애플리케이션을 지원하면서 OS를 TCB에서 제외하는 shielding system 연구들입니다.

### B. 보호된 애플리케이션에 대한 공격과 방어
Iago 공격은 악의적인 OS가 시스템 콜 반환값을 조작하여 애플리케이션을 공격할 수 있음을 보여줬습니다. InkTag, Virtual Ghost, Haven 등은 시스템 콜 인터페이스에 추가 검증을 도입하여 이를 방어합니다. Controlled-channel 공격은 Iago 공격과 달리 애플리케이션 동작을 변경하지 않고 부채널을 통해 데이터를 추출한다는 점에서 다릅니다.

### C. 부채널 공격
캐시 부채널 공격이 본 논문과 가장 관련이 깊습니다. 그러나 기존 캐시 부채널 공격은 비특권 공격자가 높은 노이즈 속에서 여러 번 실행하며 통계적으로 암호키를 추출하는 반면, controlled-channel 공격은 OS 권한으로 노이즈 없이 단일 실행만으로 문서나 이미지 같은 대용량 데이터를 추출할 수 있습니다. 또한 Flush-Reload 공격은 공유 메모리가 필요하고 제어 흐름 추적에 집중하지만, controlled-channel 공격은 공유 메모리 없이 데이터 흐름까지 추적할 수 있습니다.