---
title: "Controlled-Channel Attacks: Deterministic Side Channels for Untrusted Operating Systems"
date: 2026-02-02 00:00:00 +0900
categories: [Papers]
tags: [security, side channel]
permalink: /posts/Controlled-Channel/
math: true
---

# Summary for Controlled-Channel Attacks: Deterministic Side Channels for Untrusted Operating Systems

## Introduction
운영체제에서 계속하여 발견되는 취약점들은 운영체제가 자신과 애플리케이션을 안전하게 보호할 수 있는지에 대한 의문을 불러일으켰고, 이에 따라 작고 방어 가능한 **trusted computing base (TCB)** 를 활용하여 애플리케이션을 보호하는 **shielding system** 이 활발하게 연구되어 왔습니다. 이러한 시스템은 보통 신뢰할 수 있는 하드웨어나 하이퍼바이저를 활용하여 운영체제가 애플리케이션 메모리를 읽고 쓰거나 실행을 조작하지 못하도록 막습니다. 한편, 신뢰할 수 없는 운영체제라 하더라도 자원 관리나 표준 인터페이스 제공 같은 핵심 기능은 여전히 수행해야 합니다. 이러한 기능이 있어야 멀티태스킹, 페이징, 레거시 애플리케이션 지원이 가능하기 때문입니다. 그런데 레거시 애플리케이션들은 운영체제를 신뢰할 수 있다는 전제 하에 설계되었기 때문에, shielding system이 수정 없이 이들을 보호하려면 운영체제의 모든 적대 행위로부터 격리해야 합니다.

본 연구에서는 shielding system에 대한 새로운 부채널 공격인 **controlled-channel attack** 을 소개합니다. 신뢰할 수 없는 운영체제는 플랫폼에 대한 제어권을 바탕으로 강력한 부채널을 구성할 수 있습니다. Shielding system은 이러한 부채널을 제거하기 위해 애플리케이션, 하이퍼바이저, 격리 하드웨어에 의존할 수 없는데, 이들은 OS가 적대적인 환경을 가정하고 설계된 것이 아니기 때문입니다. 따라서 부채널을 관리하는 것은 shielding system의 몫이 되지만, 기존 시스템들은 이를 고려하지 않고 있습니다.

운영체제의 플랫폼에 대한 제어권은 기존 부채널 공격보다 훨씬 강력한 공격을 가능하게 합니다. 전통적인 부채널 공격은 컨텍스트 스위칭, 인터럽트, 예외 등 각종 시스템 이벤트로 인한 노이즈에 시달리기 때문에, 공격자는 이를 상쇄하기 위해 victim 코드를 여러 번 반복 실행해야 합니다. 반면 본 연구에서 제안하는 **no-noise channel** 은 노이즈 없이 많은 수의 가상 주소를 동시에 모니터링하고 높은 해상도로 이벤트를 관측할 수 있어, 단일 실행만으로도 대량의 데이터를 추출할 수 있습니다.

본 연구에서 제안하는 no-noise channel은 애플리케이션의 메모리 접근으로 인해 발생하는 **page fault** 를 활용합니다. 레거시 애플리케이션을 대상으로 하는 만큼 바이너리가 공개되어 있다고 가정하고, 메모리 접근 패턴에 대한 사전 분석을 바탕으로 공격을 수행합니다. 공격자는 먼저 바이너리가 로드된 베이스 주소를 추론한 뒤, **페이지 테이블을 조작** 하여 특정 코드나 데이터 페이지를 접근 불가 상태로 만듭니다. 이후 애플리케이션이 해당 페이지에 접근하면 page fault가 발생하고 운영체제가 호출되는데, 이 과정에서 어떤 페이지에 접근했는지 기록할 수 있어 애플리케이션의 페이지 접근 트레이스를 수집할 수 있습니다.

공격에는 두 가지 주요 장애물이 있습니다. 첫째, 메모리 접근을 4KB 페이지 단위로만 관측할 수 있다는 점입니다. 둘째, page fault는 비용이 큰 연산이기 때문에 단순하게 공격을 수행하면 오버헤드가 크게 증가한다는 점입니다. 본 연구에서는 페이지 단위 제약 하에서도 공격을 수행할 수 있는 기법과 오버헤드를 적정 수준으로 줄이는 최적화 기법을 함께 제시합니다.

## Background and Attack Model
Shielding system의 목표는 레거시 애플리케이션을 기존 OS 위에서 실행하되 OS를 신뢰하지 않아도 되게 하는 것입니다. 주로 하이퍼바이저나 보안 하드웨어로 구성된 **높은 권한의 monitor component** 가 운영체제의 애플리케이션 개입을 차단합니다. 이를 위해 모니터는 암호화된 디스크 스토리지 등을 통해 애플리케이션을 안전하게 초기화할 수 있어야 하고, 보호된 애플리케이션을 위한 **격리 실행 환경** 을 제공해야 합니다. 하이퍼바이저 기반 시스템은 운영체제의 페이지 테이블 수정을 가로채서 애플리케이션 메모리에 대한 접근을 차단하는 방식으로 이를 구현합니다. 애플리케이션의 가상 주소 공간 레이아웃의 무결성을 보호하는 데에도 같은 기법이 사용됩니다. 또한 모니터는 애플리케이션과 OS 사이의 컨텍스트 스위치에 개입하여 애플리케이션 상태가 운영체제에 노출되지 않도록 해야 합니다.

### A. Attack Model
공격자 모델에서는 공격자가 운영체제를 제어할 수 있지만, monitor component나 보호된 환경에서 실행되는 애플리케이션 코드는 조작할 수 없다고 가정합니다. 본 논문에서 대상으로 하는 shielding system의 특성은 다음과 같습니다.

#### Memory resource management by the operating system
운영체제는 자원 관리의 일환으로 가상-물리 주소 매핑을 관리합니다. Shielding system은 운영체제가 애플리케이션 메모리를 읽거나 쓰지 못하게 하고, 주소 공간의 무결성을 보장하도록 제약을 가할 수 있습니다. 그러나 운영체제는 **물리 페이지를 회수하여 가상-물리 매핑을 제거** 할 수 있고, page fault 처리를 위해 매핑을 복구할 수도 있어야 합니다. 이를 위해 운영체제는 page fault가 발생한 페이지의 가상 주소(페이지 베이스)를 알 수 있어야 합니다.

#### Applications
본 연구에서는 레거시 애플리케이션의 바이너리가 공개되어 있으며, 공격자가 타겟 바이너리의 정확한 버전을 알고 있다고 가정합니다. 이러한 애플리케이션들은 메모리 접근 패턴을 숨기기 위한 별도의 조치를 취하지 않습니다. 본 연구에서는 소스 코드 수준에서 애플리케이션을 분석하여 공격을 수행합니다.

## Design
공격의 핵심 아이디어는 애플리케이션이 처리하는 데이터에 따라 control transfer나 data access에서 서로 다른 패턴을 보인다는 점입니다. 이를 **input-dependent control transfer, input-dependent data access** 라고 부릅니다. 이를 관측하기 위해 운영체제는 특정 코드나 데이터 페이지를 접근 불가 상태로 만들어 **page fault trap을 유도(induce)** 할 수 있습니다. Page fault가 발생하면 해당 주소를 통해 제어 흐름이나 메모리 접근을 파악할 수 있습니다. 공격 설계에서 가장 큰 문제는 page fault 주소의 하위 12비트가 항상 0으로 마스킹되어, 페이지 내에서 정확히 어디에 접근했는지 직접 알아낼 수 없다는 점입니다.

### A. Basic Attack
```c
/* Example for input-dependent control transfer */
char* WelcomeMessage ( GENDER s ) {
    char *mesg;

    if (s == MALE){
        mesg = WelcomeMessageForMale();
    }
    else {
        mesg = WelcomeMessageForFemale();
    }
}
```

위 예시에서 `WelcomeMessage`와 다른 두 함수는 **다른 코드 페이지** 에 있다고 가정합니다. 두 함수가 있는 코드 페이지에 대한 접근을 제한해둔 다음, 둘 중 하나가 호출되면 페이지 폴트가 트리거되면서 어느 함수가 호출되었는지를 보고 사용자의 성별 정보를 유추할 수 있게 됩니다.

```c
/* Example for input-dependent data access */
void CountLogin( GENDER s ) {
    if (s == MALE){
        gMaleCount ++;
    }
    else {
        gFemaleCount ++;
    }
} 
```

위 예시에서는 두 전역 변수를 통해 남성과 여성의 로그인 횟수를 카운팅하고 있습니다. CountLogin 함수는 실행 코드이므로 코드 페이지에, 두 전역 변수는 쓰기 가능한 데이터이므로 데이터 페이지에 위치합니다. 해당 페이지들을 접근 불가 상태로 만들어 두었을 때 변수 접근 시 page fault가 발생합니다. 어느 페이지에서 fault가 발생했는지를 통해 사용자의 성별을 알 수 있고, 각 페이지의 fault 횟수를 세면 남성과 여성 사용자의 총 수도 알아낼 수 있습니다.

페이지 폴트의 정확한 주소가 주어진다면 어느 함수가 호출되었는지, 어떤 변수에 접근했는지를 바로 알아낼 수 있습니다. 하지만 주소가 페이지 단위로만 주어질 경우 이를 직접 파악할 수 없습니다.

### B. Inferring Input-Dependent Memory Accesses
공격의 첫 번째 단계는 애플리케이션 코드를 분석하여 **어떤 제어 흐름이나 데이터 접근이 입력에 의존하는지 식별** 하는 것입니다. 함수(데이터 객체)가 다른 함수들과(데이터 객체들과) 페이지를 공유하는 경우는 굉장히 흔한데, 페이지 번호만 주어졌을 때는 어떤 주소에 접근하였는지 정확히 알아낼 수가 없습니다. 본 연구에서는 어떤 함수 호출이나 데이터 접근에 대해서 **고유한 페이지 폴트 시퀀스** 를 식별하는 방식으로 접근 주소를 알아내었습니다. 

고유한 페이지 폴트 시퀀스를 식별하기 위해, **shielding system 없이** 애플리케이션을 실행합니다. 모든 페이지에 접근 제한을 걸어두고, 페이지 폴트 발생 시 해당 주소를 기록한 뒤 접근을 허용하는 방식으로 바이트 단위의 전체 페이지 폴트 트레이스를 수집합니다. 각 페이지 폴트에 대하여, 접근을 통해 페이지 폴트를 유발한 주소를 **page-fault address**, 페이지 폴트가 발생했을 때 실행되는 명령어 주소를 **instruction address of the page fault** 라고 합니다. 명령어가 두 메모리 페이지에 걸쳐있거나, page-fault address가 두 번재 페이지에 있는게 아니라면 코드 페이지 폴트 상황에서 두 주소는 같습니다. 

#### Control transfers
제어 흐름을 추론하기 위해서는 `코드 페이지의 page fault`를 기록합니다. $P_i$는 i번째 트레이스, $p_i^j$는 i번째 트레이스의 j번째 `page-fault address`를 나타낸다고 할 때 페이지 폴트 트레이스의 집합인 $\{P_i = \{p_i^j\}\}$가 수집되었다고 가정을 해봅시다. 더 나은 애플리케이션 실행 흐름 경로의 커버리지를 위해 페이지 폴트 트레이스를 여러개 수집합니다. 또한 바이너리들은 실행될 때마다 다른 주소에 로드될 수 있기 때문에, page-fault address를 모듈 오프셋으로 변환합니다.

각 트레이스 $P_i$에 대해 새로운 트레이스인 $Q_i = \{q_i^j\}$를 생성하는데, 이때 $q_i^j$는 i번째 트레이스의 j번째 페이지 폴트의 페이지 베이스 주소입니다. 공격에서 얻을 수 있는 트레이스는 $Q_i$입니다. $f$를 식별하고자 하는 제어 흐름의 타겟 주소라고 합시다. $p_s^t = f$인 모든 s, t에 대해, **제일 작은 k ≥ 1** 을 찾습니다. 이 k는 다음 조건을 만족해야 합니다: 임의의 시퀀스 $(q_i^{j-k+1}, \dots, q_i^j)$가 $(q_s^{t-k+1}, \dots, q_s^t)$와 일치할 때, **항상** $p_i^j = f$여야 합니다. 즉, 해당 페이지 시퀀스가 나타나면 반드시 f 호출임을 보장하는 최소 길이의 시퀀스를 찾는 것입니다. 함수 f가 여러 곳에서 호출될 수 있기 때문에, f에 대한 고유 시퀀스는 하나 이상 발견될 수 있습니다.

마지막으로 고유한 시퀀스인 $\{(q_s^{t-k+1},\dots,q_s^t)\}$를 활용하여 제어 흐름을 식별합니다. 실제 공격에서는 특정 제어 흐름을 추론하는데 2~3개인 페이지로 구성된 page-fault sequence가 사용되었습니다. <br>

![c1](/assets/img/posts/papers/controlled_1.png) <br>

위 그림은 같은 페이지를 공유하는 두 함수가 어떻게 page-fault sequence에 의해 구별될 수 있는지 나타내고 있습니다. 

#### Data accesses
특정 메모리 주소에 대한 데이터 접근을 추론하기 위해, shielding system 없이 코드와 데이터 페이지 모두에서 바이트 단위 페이지 폴트 트레이스를 기록합니다. 먼저 특정 주소 접근으로 인해 발생하는 data page fault들을 식별합니다. 그 다음, 각 data page fault **직전에 발생하는 code page fault 시퀀스** 중 해당 데이터 접근을 고유하게 식별할 수 있는 최소 길이의 시퀀스를 찾습니다. 동적으로 할당되는 데이터의 경우 실행 전에는 주소를 알 수 없지만, 해당 데이터에 접근하는 **명령어의 위치**는 오프라인 분석으로 알 수 있으므로 동일한 기법으로 접근을 식별할 수 있습니다.

위의 알고리즘은 싱글 스레드 환경을 가정하고 있습니다. 멀티 스레드 애플리케이션의 경우는 각 페이지 폴트에 대해 thread identifier를 기록하고, id에 기반하여 트레이스를 모읍니다. 이를 통해 스레드별 페이지 폴트 트레이스를 다루고 똑같은 알고리즘을 적용할 수 있습니다. 

### C. Handling Page Faults
#### Code pages
타겟 프로세스의 모든 코드 페이지를 추적하면 가장 많은 정보를 얻을 수 있지만, 공격이 매우 느려집니다. 대신 오프라인 분석에서 식별한 `page-fault sequence`에 포함된 페이지들(고유 시퀀스에 포함된 페이지들)만 **tracking pages**로 설정하고, 애플리케이션 실행 시 이 페이지들에 대한 접근을 제한합니다. 페이지 폴트 발생 시 이를 기록하고, 해당 페이지 접근을 허용한 뒤 이전 페이지를 다시 제한합니다.

그런데 이 방식은 **false positive** 문제가 발생할 수 있습니다. 예를 들어 고유 시퀀스 $(p_a, p_c)$가 있을 때, 실제 접근 순서가 $(p_a, p_b, p_c)$라면 원래는 매칭되지 않아야 합니다. 하지만 $p_b$가 tracking pages에 없으면 $(p_a, p_c)$로 관찰되어 잘못된 매칭이 발생합니다.

이를 해결하기 위해, 전체 트레이스를 **tracking pages 기준으로 축소** 합니다. 추적하지 않는 페이지는 제거하고 연속된 동일 페이지는 병합한 뒤, 이 축소된 트레이스에서 false positive를 유발하는 시퀀스를 찾습니다. $(p_a, p_b, p_c)$처럼 중간에 빠진 페이지가 문제가 되면, $p_b$를 tracking pages에 추가합니다.

또 다른 문제는 **명령어가 두 페이지 경계에 걸쳐 있는 경우**입니다. 두 페이지가 모두 tracking pages라면, 한 페이지를 허용하고 다른 페이지를 제한하는 과정에서 무한 루프에 빠질 수 있습니다. 이 경우 연속된 두 페이지에서 폴트가 반복되면 두 페이지 모두 접근을 허용하고, 다음 폴트 발생 시 둘 다 다시 제한합니다. 

#### Data pages
특정 함수 실행 중에만 data page fault를 추적하면 되는 경우가 많습니다. 이때 code page-fault sequence를 활용하여 함수의 시작과 끝을 감지하고, 그 사이에서만 data page fault를 추적합니다.

Data page fault 발생 시, 이전 data page에 대한 접근 제한을 다시 걸지 않아도 되는 경우가 있습니다. 특정 데이터 접근이 발생했는지 여부만 확인하면 되는 경우입니다. 반면 함수 내에서 **데이터 접근 횟수까지** 알아야 한다면, 이전 data page를 다시 제한해서 반복적인 page fault를 유발해야 합니다.

x86-64 명령어는 최대 두 개의 메모리 위치에 접근할 수 있습니다. 예를 들어 `call [funcptr]`은 함수 포인터를 읽고 스택에 리턴 주소를 씁니다. 최악의 경우 두 메모리 접근이 각각 두 페이지에 걸쳐 있으면, 네 개의 data page fault를 처리하고 모두 접근을 허용해야 명령어가 실행됩니다.

## Attacks
### FreeType
FreeType은 텍스트를 비트맵으로 렌더링하는 유저레벨 폰트 라이브러리입니다. 다양한 폰트 형식을 지원하는데, 본 연구에서는 가장 흔하게 사용되는 **TrueType** 폰트에 대해 공격을 진행합니다. TrueType 폰트에서 문자의 **글리프(glyph)** 는 선과 곡선 명령어들의 집합과 힌트들의 집합으로 표현되며, FreeType은 이 명령어들을 실행하고 힌트들을 처리하여 글리프를 비트맵에 그립니다. 글리프마다 명령어와 힌트가 다르기 때문에 렌더링 시 제어 흐름도 달라집니다. 이를 이용하여 렌더링되는 텍스트를 추론할 수 있습니다.

TrueType 렌더링 함수인 **TT_Load_Glyph** 는 문자를 렌더링할 때마다 호출됩니다. 먼저 이 함수의 시작과 끝을 감지할 수 있는 두 개의 page-fault sequence를 식별합니다. 그 다음, 모든 코드 페이지를 추적하는 대신 **TT_Load_Glyph 호출당 page-fault 횟수** 가 각 문자를 고유하게 식별할 수 있도록 추적할 코드 페이지의 부분집합을 선정합니다. 실제 공격에서는 식별해둔 시퀀스로 함수의 시작과 끝을 감지하고, 그 사이의 page-fault 횟수를 오프라인 분석 결과와 비교하여 각 문자를 식별합니다.

### Hunspell
Hunspell은 많은 소프트웨어 패키지에서 널리 사용되는 맞춤법 검사 도구입니다. Hunspell은 사전의 단어들을 메모리의 해시 테이블로 로드하고, 단어가 해시 테이블에 있는지를 확인하여 맞춤범을 검사합니다. 해시 테이블은 분리 연결법 방식으로 해시 충돌을 처리하는데, 해시 테이블은 연결 리스트들을 가리키는 포인터 배열로 구성되고, 배열의 인덱스는 해시값입니다. 그리고 각 연결 리스트에는 같은 해시값을 가진 단어들이 들어있습니다. 해시 테이블 예시는 아래 그림에서 확인할 수 있습니다. <br>

![c2](/assets/img/posts/papers/controlled_2.png) <br>

